// ** MUI Imports
import Card from '@mui/material/Card';
import CardContent from '@mui/material/CardContent';
import CardHeader from '@mui/material/CardHeader';
import Grid from '@mui/material/Grid';

import { useTranslation } from 'react-i18next';

// ** Custom Components Imports
import {
  Alert,
  AlertTitle,
  Box,
  Button,
  Divider,
  IconButton,
  LinearProgress,
  Tooltip,
  Typography,
  capitalize,
  responsiveFontSizes,
} from '@mui/material';
import { useEffect, useState } from 'react';
import { handleError, hasRole, nameof } from 'src/@core/coreHelper';
import { IEntitySchema, IEntitySchemaField, IEntitySchemaWithFields } from 'src/types/entities';
import {
  CMSCollections,
  IApplicant,
  IPatient,
  IPatientRelative,
  IRelative,
  RelativeTypes,
} from 'src/types/@autogenerated';
import { useDynamics } from 'src/hooks/useDynamics';
import { schemaToForm, updateEntityDataBySchema } from '../components/dynamics/helpers';
import { useCurrentUser } from 'src/hooks/useCurrentUser';
import { IForm } from 'src/types/dynamics';
import { UserDefinedRols } from 'src/types/userDefinedRols';
import { AppRols } from 'src/types/appRols';
import { Icon } from '@iconify/react';
import { DataGrid, GridColDef } from '@mui/x-data-grid';
import CustomTextField from 'src/@core/components/mui/text-field';
import { dynamicCreate, dynamicGet, dynamicUpdate } from 'src/services/entitiesDynamicServices';
import { IUser } from 'src/types/users';
import RelativeForm from './form';

interface PropsType {
  docId: string;
  schemaArg: IEntitySchema;
  dataArg: IPatient;
  schemaFieldsArg: IEntitySchemaField[];
  onUpdatePatient: () => Promise<any>;
}

interface IPatientRelativeRow extends IPatientRelative {
  showRow: boolean;
  lastName: string;
  firstName: string;
  email: string;
}
interface CellType {
  row: IPatientRelativeRow;
}

const PATIENT_RELATIVES = CMSCollections.PATIENT_RELATIVES;
const RELATIVES = CMSCollections.RELATIVES;

const SCHEMA_NAME = CMSCollections.PATIENT_RELATIVES;
const RelativeGrid = ({ docId, schemaArg, dataArg, schemaFieldsArg, onUpdatePatient }: PropsType) => {
  // ** Hooks
  const dynamics = useDynamics();
  const { t } = useTranslation();
  const currentUser = useCurrentUser();

  // ** State
  const [entitySchema, setEntitySchema] = useState<IEntitySchema>(schemaArg);
  const [entitySchemaFields, setEntitySchemaFields] = useState<IEntitySchemaField[]>(schemaFieldsArg);
  const [loadingSchema, setLoadingSchema] = useState<boolean>(true);
  const [loadingData, setLoadingData] = useState<boolean>(false);
  const [toggleData, setToggleData] = useState<boolean>(false);

  const [editEntityForm, setEditEntityForm] = useState<IForm | null>(null);
  const [isCreating, setIsCreating] = useState<boolean>(true);
  const [relativeData, setRelativeData] = useState<IPatientRelativeRow>();
  const [entitiesData, setEntitiesData] = useState<IPatientRelativeRow[]>([]);

  //- side drawer
  const [openSideDrawer, setOpenSideDrawer] = useState<boolean>(false);
  const toggleSideDrawer = () => setOpenSideDrawer(!openSideDrawer);

  //- grid
  const [paginationModel, setPaginationModel] = useState({ page: 0, pageSize: 100 });
  const [columns, setColumns] = useState<GridColDef[]>([]);
  const [searchText, setSearchText] = useState<string>('');

  const isPermittedByRol = () => {
    return (
      !currentUser.isLoading &&
      !!currentUser.currentUser &&
      (hasRole(currentUser.currentUser?.appRols, AppRols.APP_ADMIN) ||
        hasRole(currentUser.currentUser?.userDefinedRols, UserDefinedRols.UDR_STAFF_ADMISSION))
    );
  };

  const updateColumnsData = () => {
    const columnsData: GridColDef[] = [];

    // icons col
    columnsData.push({
      flex: 0.1,
      minWidth: 110,
      field: 'icons',
      headerName: '',

      renderCell: ({ row }: CellType) => (
        <Box sx={{ display: 'flex', alignItems: 'center' }}>
          <Tooltip title='View Content'>
            <IconButton
              size='small'
              sx={{ color: 'text.secondary' }}
              onClick={() => {
                handleEdit(row);
              }}
            >
              <Icon icon='tabler:eye' />
            </IconButton>
          </Tooltip>
        </Box>
      ),
    });

    // id col
    columnsData.push({
      flex: 0.2,
      minWidth: 110,
      field: 'id',
      headerName: 'id',

      renderCell: ({ row }: CellType) => (
        <Typography
          noWrap
          sx={{
            fontWeight: 500,
            textDecoration: 'none',
            color: 'text.secondary',
            '&:hover': { color: 'primary.main' },
            cursor: 'pointer',
          }}
        >
          {row.id}
        </Typography>
      ),
    });

    columnsData.push({
      flex: 0.2,
      minWidth: 110,
      field: 'type',
      headerName: t('type') as string,

      renderCell: ({ row }: CellType) => {
        return (
          <>
            <Box sx={{ display: 'flex', alignItems: 'flex-start', flexDirection: 'column' }}>
              <Typography
                noWrap
                sx={{
                  fontWeight: 500,
                  textDecoration: 'none',
                  color: 'text.secondary',
                  '&:hover': { color: 'primary.main' },
                  textTransform: 'capitalize',
                }}
              >
                {t(row.relationshipType)}
              </Typography>
            </Box>
          </>
        );
      },
    });

    columnsData.push({
      flex: 0.2,
      minWidth: 110,
      field: 'Name',
      headerName: capitalize(t('name')) as string,

      renderCell: ({ row }: CellType) => {
        return (
          <>
            <Box sx={{ display: 'flex', alignItems: 'flex-start', flexDirection: 'column' }}>
              <Typography
                noWrap
                sx={{
                  fontWeight: 500,
                  textDecoration: 'none',
                  color: 'text.secondary',
                  '&:hover': { color: 'primary.main' },
                  textTransform: 'capitalize',
                }}
              >
                {`${row.firstName} ${row.lastName}`}
              </Typography>
              <Typography noWrap variant='body2' sx={{ color: 'text.disabled' }}>
                {row.email}
              </Typography>
            </Box>
          </>
        );
      },
    });
    setColumns(columnsData);
  };

  useEffect(() => {
    const doAsync = async () => {
      try {
        setLoadingSchema(true);
        if (dynamics.isLoadingSchemas || !dynamics.entitySchemas || !dynamics.entitySchemasFields) return null;

        const schema = dynamics.entitySchemas.find((schema) => {
          return schema.name === SCHEMA_NAME;
        });
        if (!schema) throw new Error('Missing schemaName: ' + SCHEMA_NAME);

        const schemaFields = dynamics.entitySchemasFields.filter((field) => {
          return field.schemaId === schema.id;
        });

        // Fetch Schema
        // const entitySchemaResponse = (await getEntitySchemaByName(schemaName)) as IEntitySchemaWithFields;
        const entitySchemaResponse: IEntitySchemaWithFields = { ...schema, fields: schemaFields };

        setEntitySchema(entitySchemaResponse);
        setEntitySchemaFields(
          entitySchemaResponse.fields.sort((a, b) => {
            return a.order - b.order;
          })
        );

        setLoadingSchema(false);
      } catch (e: any) {
        handleError(e);
        setLoadingSchema(false);
      }
    };

    doAsync();
  }, [dynamics.isLoadingSchemas]);

  // define columns and filters
  useEffect(() => {
    const doAsync = async () => {
      try {
        if (!entitySchema || !entitySchemaFields) return;

        // Define table columns
        updateColumnsData();
      } catch (e: any) {
        handleError(e);
      }
    };

    doAsync();
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [entitySchema, entitySchemaFields]);

  // Fetch schema.collectionName
  useEffect(() => {
    const doAsync = async () => {
      try {
        if (!entitySchema || !entitySchemaFields) return;

        // Define table columns
        updateColumnsData();

        setLoadingData(true);

        // load entity data
        const data: any = await dynamicGet({
          params: '/cms/' + PATIENT_RELATIVES + '/by-prop/' + nameof<IPatientRelative>('patientId') + '/' + dataArg.id,
        });

        const posts = await Promise.all(
          data.items.map(async (relative: IPatientRelative) => {
            const basicData = await getBasicData(relative.relativeId, relative);
            if (basicData) return basicData;

            return;
          }) as IPatientRelativeRow[]
        );
        setEntitiesData(posts);

        setLoadingData(false);
      } catch (e: any) {
        setLoadingData(false);
        handleError(e);
      }
    };

    doAsync();
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [entitySchema, entitySchemaFields]);

  const onSubmitRelative = async (formData: any, action: any) => {
    try {
      setLoadingData(true);
      if (!formData) throw new Error(t('data is missing') as string);

      const relativeForm = {
        firstName: formData.firstName,
        lastName: formData.lastName,
        email: formData.email,
      } as IUser;

      const patientRelativeForm = {
        patientId: docId,
        relationshipType: formData.relationshipType,
      } as IPatientRelative;

      if (action.isCreating) {
        const userCreationResponse = await createEntity(relativeForm, RELATIVES);
        if (userCreationResponse) {
          patientRelativeForm.relativeId = userCreationResponse.userId;
          createEntity({ ...patientRelativeForm }, PATIENT_RELATIVES);
        }
      } else {
        updateEntity(relativeForm, RELATIVES, formData.relativeId);
        updateEntity(patientRelativeForm, PATIENT_RELATIVES, formData.id);
      }
      onUpdatePatient();

      setLoadingData(false);
    } catch (e) {
      handleError(e);
      setLoadingData(false);
    }
  };
  const createEntity = async (formData: any, schema: string) => {
    let response = null;

    response = await dynamicCreate({
      params: `/cms/${schema}/`,
      data: formData,
    });

    return response;
  };
  const updateEntity = async (formData: any, schema: string, id: string) => {
    let response = null;

    response = await dynamicUpdate({
      params: `/cms/${schema}/` + id,
      data: formData,
    });

    return response;
  };
  const getBasicData = async (id: string, relative: IPatientRelative) => {
    const basicData = await dynamicGet({
      params: '/cms/' + RELATIVES + '/by-user/' + id,
    });

    if (basicData && basicData.items && basicData.items[0]) {
      const row = {
        firstName: basicData.items[0].firstName,
        lastName: basicData.items[0].lastName,
        email: basicData.items[0].email,
        showRow: true,
        relationshipType: relative.relationshipType,
        patientId: relative.patientId,
        relativeId: relative.relativeId,
        id: relative.id,
      } as IPatientRelativeRow;

      return row;
    }

    return;
  };

  const setNewRelative = () => {
    const newRelative = {
      firstName: '',
      lastName: '',
      email: '',
      showRow: true,
      relationshipType: RelativeTypes.MOTHER,
      patientId: docId,
      relativeId: '',
      id: '',
    } as IPatientRelativeRow;

    return newRelative;
  };
  const handleEdit = (row: IPatientRelativeRow) => {
    setRelativeData(row);
    setOpenSideDrawer(true);
    setIsCreating(false);
  };

  return (
    <Grid container spacing={6}>
      <Grid item xs={12}>
        <Card>
          <CardContent>
            <Grid container spacing={6}></Grid> <Divider sx={{ m: '0 !important' }} />
            <Box
              sx={{
                py: 4,
                px: 6,
                rowGap: 2,
                columnGap: 4,
                display: 'flex',
                flexWrap: 'wrap',
                alignItems: 'center',

                justifyContent: 'right',
              }}
            >
              <Box sx={{ rowGap: 2, display: 'flex', flexWrap: 'wrap', alignItems: 'center' }}>
                <CustomTextField
                  sx={{ mr: 4 }}
                  placeholder={capitalize(t('search placeholder'))}
                  onChange={(e) => setSearchText(e.target.value)}
                />
                {isPermittedByRol() && (
                  <Button
                    onClick={() => {
                      setIsCreating(true);
                      setOpenSideDrawer(true);
                      setRelativeData(setNewRelative());
                    }}
                    variant='contained'
                    sx={{ '& svg': { mr: 2 } }}
                  >
                    <Icon fontSize='1.125rem' icon='tabler:plus' />
                    {capitalize(t('new'))}
                  </Button>
                )}
              </Box>
            </Box>
            <DataGrid
              autoHeight
              rows={entitiesData.filter((item) => {
                if (item) return item.showRow;
              })}
              rowHeight={60}
              loading={loadingData}
              columns={columns}
              initialState={{
                columns: {
                  columnVisibilityModel: {
                    id: false,
                  },
                },
              }}
              disableRowSelectionOnClick
              pageSizeOptions={[7, 10, 25, 50]}
              paginationModel={paginationModel}
              onPaginationModelChange={setPaginationModel}
            />
          </CardContent>
        </Card>

        {!!openSideDrawer && (
          <RelativeForm
            docId={docId}
            isCreating={isCreating}
            onSubmit={onSubmitRelative}
            title={'Edit'}
            formId={'edit relative'}
            initialValues={relativeData}
            preloadForm={editEntityForm}
            open={openSideDrawer}
            toggle={toggleSideDrawer}
            onSubmitDone={() => {
              toggleSideDrawer();

              return Promise.resolve();
            }}
          />
        )}
      </Grid>
    </Grid>
  );
};

export default RelativeGrid;
