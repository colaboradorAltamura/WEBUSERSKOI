// ** React Imports
import { useCallback, useEffect, useRef, useState } from 'react';

// ** MUI Imports
import Box from '@mui/material/Box';

import { AutocompleteRenderOptionState } from '@mui/material/Autocomplete';
import ListItem from '@mui/material/ListItem';
import ListItemButton from '@mui/material/ListItemButton';
import Typography from '@mui/material/Typography';
import { useTheme } from '@mui/material/styles';

// ** Third Party Imports

import debounce from 'debounce-promise';

// ** Types Imports
import { SearchEntitiesOptionType } from 'src/types';

// ** Icon Imports
import Icon from 'src/@core/components/icon';

// ** Custom Component Import
import CustomAutocomplete from 'src/@core/components/mui/autocomplete';

// ** Configs Imports

import { Link, capitalize } from '@mui/material';
import { useFormikContext } from 'formik';
import CustomTextField from 'src/@core/components/mui/text-field';
import { COUNTRY_CONSTRAINTS_PROP_NAME, getSourceEntityData, handleError } from 'src/@core/coreHelper';
import { useSettings } from 'src/@core/hooks/useSettings';
import { useDynamics } from 'src/hooks/useDynamics';
import { IDynamicFormSelectComponent, IDynamicFormComponent } from 'src/types/dynamics';
import { createEntityDataBySchema, invokeEvent, schemaToForm } from './helpers';
import { dynamicGet } from 'src/services/entitiesDynamicServices';
import { EntitySchemaTypes, IEntitySchema, IEntitySchemaWithFields } from 'src/types/entities';
import { useCurrentUser } from 'src/hooks/useCurrentUser';
import { useTranslation } from 'react-i18next';
import Loader from 'src/@core/components/loader';
import { IEntity } from 'src/types/@autogenerated';

interface PropsType {
  component: IDynamicFormSelectComponent;
  isCreating?: boolean;
  showAddNew?: boolean;
}

interface OptionsType {
  label: string;
  value: any;
  isOptionField: boolean;
  raw: any;
}

const DynamicFormComponentSelectAsync = ({ component: selectComponent, isCreating, showAddNew }: PropsType) => {
  // ** Hooks & Vars
  const { settings } = useSettings();
  const { t } = useTranslation();
  const theme = useTheme();
  const dynamics = useDynamics();
  const { values, setFieldValue, errors } = useFormikContext();
  const currentUser = useCurrentUser();

  // ** States
  const [readyState, setReadyState] = useState<boolean>(false);

  const [searchValue, setSearchValue] = useState<string>('');
  const [isLoading, setIsLoading] = useState<boolean>(false);
  const [options, setOptions] = useState<OptionsType[]>([]);
  const [initialValueFirstRender, setInitialValueFirstRender] = useState<boolean>(true);
  const [loadingPreloadInfo, setLoadingPreloadInfo] = useState<boolean>(true);
  const [initialized, setInitialized] = useState<boolean>(false);

  const [preloaded, setPreloaded] = useState<boolean>(false);

  const [addNewRelatedSchema, setAddNewRelatedSchema] = useState<IEntitySchemaWithFields | null>(null);

  const theValues = values as any;
  const theErrors = errors as any;

  const auxRef = useRef(null);

  // const [initialValue, setInitialValue] = useState<any>(theValues[component.name]);

  const searchEntitiesDebounced = (updatedValues: any, text: string) => {
    try {
      console.log('Search entities: ' + text);

      if (!selectComponent.dataSource || !selectComponent.dataSource.event) {
        throw new Error('no event defined in select async component');
      }
      const eventDefinition = selectComponent.dataSource.event;

      return invokeEvent(dynamics, [eventDefinition], eventDefinition.name, { text, ...updatedValues }, false);
    } catch (e) {
      handleError(e);

      return null;
    }
    // return searchEntities({ filters });
  };

  // eslint-disable-next-line react-hooks/exhaustive-deps
  const searchDbounce = useCallback(debounce(searchEntitiesDebounced, 1000), []);

  const processFetchedResponse = (responseItems: any[], allowEmpty: boolean, isPreloaded: boolean) => {
    let ops = responseItems
      .filter((item: any) => {
        // TODO como hacer para saber cual es el campo que filtra por country
        if (
          item &&
          item[COUNTRY_CONSTRAINTS_PROP_NAME] &&
          item[COUNTRY_CONSTRAINTS_PROP_NAME].length &&
          (!settings.codeCountry || !item[COUNTRY_CONSTRAINTS_PROP_NAME].includes(settings.codeCountry))
        ) {
          return false;
        }

        return true;
      })
      .map((item: any) => {
        let retString = '';
        selectComponent.optionLabelProps?.forEach((element: any) => {
          let separator = ' ';

          if (selectComponent.optionLabelPropsSeparator) separator = selectComponent.optionLabelPropsSeparator;
          if (isPreloaded) {
            if (item[element]) retString += capitalize(t(item[element])) + separator;
          } else {
            if (item[element]) retString += capitalize(item[element]) + separator;
          }
          // retString += element.label + selectComponent.optionLabelPropsSeparator;
        });

        return {
          label: retString.trimEnd(),
          value: item[selectComponent.optionIdProp ? selectComponent.optionIdProp : 0],
          isOptionField: true,
          raw: item,
        };

        // return { label: item.name, value: item.id };
      });

    if (allowEmpty) {
      ops = [
        {
          label: '',
          value: '',
          isOptionField: true,
          raw: null,
        },
        ...ops,
      ];
    }

    setOptions(ops);
  };

  const getDataLabel = (item: any) => {
    let itemLabel = (item as any).name;

    if (item['@schemaId']) {
      const itemRelatedSchema = dynamics.entitySchemas?.find((schemaItem) => {
        return schemaItem.id === item['@schemaId'];
      });

      if (itemRelatedSchema && (item as any)[itemRelatedSchema.fieldNameUsedAsSchemaLabel]) {
        itemLabel = (item as any)[itemRelatedSchema.fieldNameUsedAsSchemaLabel];
      }
    }

    return itemLabel;
  };

  // Ejecuta funciones de inicializaciÃ³n y setea el ready state
  useEffect(() => {
    const doAsync = async () => {
      try {
        if (!values || readyState) return;

        if (selectComponent.onInit) {
          await selectComponent.onInit(values, setFieldValue);
        }
        setReadyState(true);
      } catch (e) {
        handleError(e);
      }
    };
    doAsync();
  }, [values]);

  // evalua la prop showCreateNewItem y obtiene el esquema para mostrar ese comp
  useEffect(() => {
    if (!readyState) return;

    if (selectComponent && selectComponent.showCreateNewItem) {
      const entitySchema = dynamics.entitySchemas?.find((schema) => {
        return schema.id === selectComponent.dataSource.schemaId;
      });

      const entitySchemaFields = dynamics.entitySchemasFields
        ?.filter((field) => {
          return field.schemaId === selectComponent.dataSource.schemaId;
        })
        .sort((a, b) => {
          return a.order - b.order;
        });

      if (
        entitySchema &&
        entitySchemaFields &&
        showAddNew &&
        (entitySchema.schemaType === EntitySchemaTypes.MAIN_ENTITY ||
          entitySchema.schemaType === EntitySchemaTypes.SELECT_OPTIONS_ENTITY)
        // || entitySchema.schemaType === EntitySchemaTypes.USER_ENTITY // un chino si dejo esto aca
      ) {
        setAddNewRelatedSchema({ ...entitySchema, fields: entitySchemaFields });
      }
    }
  }, [selectComponent, readyState]);

  // obtiene la info prelodeable en caso de aplicar
  // define el valor inicial del select
  useEffect(() => {
    const doAsync = async () => {
      if (!readyState) return;

      setLoadingPreloadInfo(true);

      try {
        if (!theValues) {
          console.error('Missing theValues');

          return;
        }

        if (!dynamics.entitySchemas) return;

        // TODO Michel saco esta validacion porque el "selectComponent.onInit" pretende que se ejecute esta parte
        // if (!theValues[selectComponent.name]) {
        // if (!selectComponent.dataSource.schemaId) {
        //   setLoadingPreloadInfo(false);

        //   return;
        // }

        const entitySchema = dynamics.entitySchemas.find((item) => {
          return item.id === selectComponent.dataSource.schemaId;
        });

        let preloaded = false;

        // si el esquema relacionado es prelodeable entonces le pego al endpoint asociado y traigo los datos,
        // el dynamicGet cachea la info para proximas consultas
        if (entitySchema?.prelodeable) {
          const response = await dynamicGet({ params: '/cms/' + entitySchema.name });

          if (response && response.items && response.items.length) {
            processFetchedResponse(response.items, true, entitySchema?.prelodeable);
            setPreloaded(true);
            preloaded = true;
          }
        }

        // }
        setLoadingPreloadInfo(false);

        const sourceData = getSourceEntityData({ obj: theValues, key: selectComponent.name });

        if (sourceData) {
          const auxInitialOptions: OptionsType[] = [];

          if (Array.isArray(sourceData)) {
            sourceData.forEach((item: IEntity) => {
              const itemLabel = getDataLabel(item);

              auxInitialOptions.push({
                label: itemLabel,
                value: item.id,
                isOptionField: true,
                raw: item,
              });
            });

            if (!preloaded) setOptions(auxInitialOptions);

            setFieldValue(selectComponent.name, auxInitialOptions, true);
            // setSearchValue(auxInitialOptions[0].label);
          } else {
            const itemLabel = getDataLabel(sourceData);

            auxInitialOptions.push({
              label: itemLabel,
              value: theValues[selectComponent.name],
              isOptionField: true,
              raw: sourceData,
            });

            // tengo todas las opciones posibles precargadas, quiere decir que ya tengo el select completo, entonces no hace falta setear la opcion.
            // Esto aplica para valores dinamicos que se buscan
            if (!preloaded) setOptions(auxInitialOptions);

            // setFieldValue(selectComponent.name, initialOption.value, true);
            setFieldValue(selectComponent.name, auxInitialOptions[0], true);
            // setSearchValue(auxInitialOptions[0].label);
          }
        }

        setInitialized(true);

        setIsLoading(false);
      } catch (e) {
        setIsLoading(false);
        handleError(e);
      }
    };

    doAsync();
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [dynamics.entitySchemas, readyState]);

  // hace el fetch de datos con cada cambio en el search
  useEffect(() => {
    const doAsync = async () => {
      try {
        if (!readyState || !dynamics.entitySchemas || loadingPreloadInfo || !initialized) return;

        // Esto es para que no se dispare la busqueda luego de setear el valor inicial del select.
        // Con este flag evito que corra la primera vez que se setea el searchValue
        if (initialValueFirstRender) {
          setInitialValueFirstRender(false);

          return;
        }

        // No hago ningun search en caso que haya sido preloaded
        if (preloaded) {
          return;
        }

        if (searchValue === '') {
          setOptions([]);

          return;
        }

        setIsLoading(true);

        const response = await searchDbounce(theValues, searchValue);

        if (response && response.items && response.items.length) {
          processFetchedResponse(response.items, false, preloaded);
        } else {
          setOptions([]);
        }

        setIsLoading(false);
      } catch (e) {
        setIsLoading(false);
        handleError(e);
      }
    };

    doAsync();
  }, [searchValue, dynamics.entitySchemas, readyState, loadingPreloadInfo, initialized]);

  // Handle ESC & shortcut keys keydown events
  // const handleKeydown = useCallback((event: KeyboardEvent) => {
  //   // ** Shortcut keys to open searchbox (Ctrl + /)
  // }, []);

  // useEffect(() => {
  //   document.addEventListener('keydown', handleKeydown);

  //   return () => {
  //     document.removeEventListener('keydown', handleKeydown);
  //   };
  // }, [handleKeydown]);

  // Handle click event on a list item in search result
  const handleOptionClick = (obj: OptionsType) => {
    setSearchValue('');

    if (obj) setFieldValue(selectComponent.name, obj, true);
    else setFieldValue(selectComponent.name, '', true);
    setIsLoading(false);

    if (selectComponent.onChange && obj) {
      selectComponent.onChange(obj.raw, values, setFieldValue);
    }
    // console.log('Options: ', options);

    // onEntitySelected(obj.rawObject);
    // setOpenDialog(false);
  };

  const getOptionLabel = (option: any) => {
    if (preloaded) return t(option.label);
    else option.label;
  };

  const getCurrentOptionLabel = (option: any) => {
    if (preloaded) return option.label || option.label === '' ? t(option.label) : t(option);
    else return option.label || option.label === '' ? option.label : option;
  };

  const renderAutocompleteOption = (props: any, option: any | unknown, state: AutocompleteRenderOptionState) => {
    return searchValue.length || preloaded ? (
      <ListItem
        {...props}
        key={state.index}
        className={`suggestion ${props.className}`}
        onClick={(e) => {
          handleOptionClick(option as OptionsType);

          // const event = new KeyboardEvent('keydown', {
          //   key: 'Escape',
          // });
          // document.dispatchEvent(event);
        }}
        secondaryAction={<Icon icon='tabler:corner-down-left' fontSize='1.25rem' />}
        sx={{
          '& .MuiListItemSecondaryAction-root': {
            '& svg': {
              cursor: 'pointer',
              color: 'text.disabled',
            },
          },
        }}
      >
        <ListItemButton
          sx={{
            py: 2,
            px: `${theme.spacing(6)} !important`,
            '& svg': { mr: 2.5, color: 'text.primary' },
          }}
        >
          {/* <Icon icon={(option as SearchEntitiesOptionType).icon || themeConfig.navSubItemIcon} /> */}
          <Typography>{getOptionLabel(option)}</Typography>
        </ListItemButton>
      </ListItem>
    ) : null;
  };

  const isError = theErrors && theErrors[selectComponent.name] ? true : false;

  if (!values) return null;

  const handleCreateNewItem = () => {
    if (!addNewRelatedSchema) {
      handleError(new Error('Missing addNewRelatedSchema'));

      return;
    }

    const schemaForm = schemaToForm(addNewRelatedSchema, addNewRelatedSchema.fields, null, dynamics, false);

    dynamics.openDyamicForm({
      isCreating: true,
      onSubmit: async (data: any) => {
        if (!currentUser || !currentUser.currentUser) {
          handleError(new Error('Missing currentUser'));

          return;
        }

        const creationResult = await createEntityDataBySchema(
          currentUser.currentUser,
          addNewRelatedSchema,
          addNewRelatedSchema.fields,
          data,
          null,
          null
        );

        // horrible...
        data.id = creationResult.id;
      },
      title: 'Create ' + addNewRelatedSchema.name,
      formId: 'Create_' + addNewRelatedSchema.name,
      initialValues: {},
      preloadForm: schemaForm,
      onSubmitDone: (data: any) => {
        const newOp = {
          label: data.name,
          value: data.id,
          isOptionField: true,
          raw: data,
        };

        setOptions([...options, newOp]);

        handleOptionClick(newOp);

        dynamics.closeDyamicForm();
      },
    });
  };

  if (loadingPreloadInfo) return <Loader />;

  return (
    <>
      <Box sx={{ top: 0, width: '100%', position: 'sticky' }} ref={auxRef}>
        <CustomAutocomplete
          multiple={false}
          disabled={(selectComponent.readOnly?.create && isCreating) || (selectComponent.readOnly?.edit && !isCreating)}
          fullWidth
          noOptionsText={selectComponent.noOptionsText}
          loading={isLoading}
          value={theValues[selectComponent.name]}
          options={options}
          onInputChange={(event, value: string) => {
            // Esto se ejecuta la primera vez que se carga el comp y tmb con cada click en una opcion
            // si los valores son iguales no hace nada, caso constrario setea el searchValue
            // Cuando se inicializa el comp esto tmb se ejecuta pero como son iguales el label y el value no hace nada
            if (theValues[selectComponent.name] && theValues[selectComponent.name].label === value && value !== '')
              return;

            setSearchValue(value);
          }}
          onChange={(event, obj) => {
            handleOptionClick(obj as any);
          }}
          // si uso esta fn me pasa que no se cierra el dropdown cuando selecciono un item
          // renderOption={(props, option: SearchEntitiesOptionType | unknown, state: AutocompleteRenderOptionState) => {
          //   return renderAutocompleteOption(props, option, state);
          // }}
          getOptionLabel={(option: any | unknown) => getCurrentOptionLabel(option) || ''}
          isOptionEqualToValue={(option, value) => {
            if (option && option.value === value) return true;
            else if (option === value) return true;

            return false;
          }}
          renderInput={(params) => {
            if (loadingPreloadInfo) return <Loader />;

            return (
              <CustomTextField
                {...params}
                sx={{ textTransform: 'capitalize' }}
                error={isError}
                helperText={isError ? selectComponent.errorMsg : selectComponent.tooltip}
                fullWidth
                label={t(selectComponent.label ? selectComponent.label : '')}
              />
            );
          }}
        />
        {!!addNewRelatedSchema && (
          <Link
            style={{ cursor: 'pointer' }}
            onClick={() => {
              handleCreateNewItem();
            }}
          >
            {' '}
            or create new
          </Link>
        )}
      </Box>
    </>
  );
};

export default DynamicFormComponentSelectAsync;
