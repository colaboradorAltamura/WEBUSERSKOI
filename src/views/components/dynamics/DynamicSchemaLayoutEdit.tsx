import { SyntheticEvent, useEffect, useState } from 'react';

// ** MUI Imports
import Box from '@mui/material/Box';
import Button from '@mui/material/Button';
import Card from '@mui/material/Card';
import CardActions from '@mui/material/CardActions';
import CardContent from '@mui/material/CardContent';
import Divider from '@mui/material/Divider';
import Grid from '@mui/material/Grid';
import Typography from '@mui/material/Typography';

// ** Icon Imports

// ** Custom Components
import CustomAvatar from 'src/@core/components/mui/avatar';

// ** Types

import TabContext from '@mui/lab/TabContext';
import TabList from '@mui/lab/TabList';
import TabPanel from '@mui/lab/TabPanel';
import { useRouter } from 'next/router';
import Loader from 'src/@core/components/loader';
import {
  USERS_SCHEMA,
  capitalize,
  getSourceEntityData,
  handleError,
  parseDateToDateTimeString,
  splitByUppercase,
} from 'src/@core/coreHelper';
import { getInitials } from 'src/@core/utils/get-initials';
import { DynamicComponentTypes, IForm, ILayoutPanel } from 'src/types/dynamics';
import { EntitySchemaTypes, IEntitySchema, IEntitySchemaField, IEntitySchemaWithFields } from 'src/types/entities';

import Alert from '@mui/material/Alert';
import AlertTitle from '@mui/material/AlertTitle';
import IconButton from '@mui/material/IconButton';
import Tab from '@mui/material/Tab';
import { toast } from 'react-hot-toast';
import Icon from 'src/@core/components/icon';
import { useCurrentUser } from 'src/hooks/useCurrentUser';
import { useDynamics } from 'src/hooks/useDynamics';
import { getStoredFileDownloadUrl } from 'src/services/attachmentsServices';
import { IAddress, IAttachment } from 'src/types/@autogenerated';
import { IUser } from 'src/types/users';
import DynamicFormSidebar from './DynamicFormSidebar';
import DynamicSchemaLayoutEditTabContent from './DynamicSchemaLayoutEditTabContent';
import {
  getEditEntityForm,
  getEntityDataBySchema,
  removeEntityDataBySchema,
  restoreEntityDataBySchema,
  updateEntityDataBySchema,
} from './helpers';
import _ from 'lodash';

interface PropsType {
  useCmsRoutes?: boolean;
  parentEntitySchema?: IEntitySchema;
  parentEntityData?: any;

  schemaName: string;
  id: string;

  panels: ILayoutPanel[] | null;
  onSchemaFetched?: (schena: IEntitySchema) => void;
}

const DynamicSchemaLayoutEdit = ({
  useCmsRoutes,
  parentEntitySchema,
  parentEntityData,
  schemaName,
  id,
  onSchemaFetched,
  panels,
}: PropsType) => {
  // ** Hooks
  const router = useRouter();
  const currentUser = useCurrentUser();
  const dynamics = useDynamics();

  // ** State
  const [entitySchema, setEntitySchema] = useState<IEntitySchema | null>(null);
  const [entitySchemaFields, setEntitySchemaFields] = useState<IEntitySchemaField[]>([]);
  const [panelsState, setPanelsState] = useState<ILayoutPanel[] | null>(panels);

  const [entityData, setEntityData] = useState<any>(null);

  const [loadingSchema, setLoadingSchema] = useState<boolean>(true);
  const [loadingData, setLoadingData] = useState<boolean>(true);
  const [loadingPanels, setLoadingPanels] = useState<boolean>(true);

  const tab = router.query['tab'] as string;

  const [activeTab, setActiveTab] = useState<string>(tab);

  const [editEntityForm, setEditEntityForm] = useState<IForm | null>(null);
  const [editSidebarOpen, setEditSidebarOpen] = useState<boolean>(false);

  const [toggleData, setToggleData] = useState<boolean>(false);

  const toggleEditDrawer = () => setEditSidebarOpen(!editSidebarOpen);

  // ** Effects
  useEffect(() => {
    if (!schemaName) return;

    const doAsync = async () => {
      try {
        setLoadingSchema(true);

        if (dynamics.isLoadingSchemas || !dynamics.entitySchemas || !dynamics.entitySchemasFields) return null;

        const schema = dynamics.entitySchemas.find((schema) => {
          return schema.name === schemaName;
        });
        if (!schema) throw new Error('Missing schemaName: ' + schemaName);
        const schemaFields = dynamics.entitySchemasFields.filter((field) => {
          return field.schemaId === schema.id;
        });

        // Fetch Schema
        //const entitySchemaResponse = (await getEntitySchemaByName(schemaName)) as IEntitySchemaWithFields;
        const entitySchemaResponse: IEntitySchemaWithFields = { ...schema, fields: schemaFields };

        if (onSchemaFetched) onSchemaFetched(entitySchemaResponse);

        setEntitySchema(entitySchemaResponse);

        // Fetch Fields
        // const entitySchemaFieldsResponse = await listEntitySchemaFields(entitySchemaResponse.id);

        setEntitySchemaFields(
          entitySchemaResponse.fields.sort((a, b) => {
            return a.order - b.order;
          })
        );

        setLoadingSchema(false);
      } catch (e: any) {
        handleError(e);
        setLoadingSchema(false);
      }
    };

    doAsync();
  }, [schemaName, dynamics.isLoadingSchemas]);

  useEffect(() => {
    if (!entitySchema) return;

    const doAsync = async () => {
      try {
        // si vienen prefijados no busco los relacionados sino que uso esos directamente
        if (!panelsState) {
          setLoadingPanels(true);

          if (!dynamics.entitySchemas) return;

          // Fetch all organization Schemas
          // const entitiesSchemasResponse = await listEntitiesSchemas();

          const relatedSchemasToShow = dynamics.entitySchemas.filter((item) => {
            return item.relationshipSourceSchemaId === entitySchema.id;
          });

          if (entitySchema.schemaType === EntitySchemaTypes.USER_ENTITY) {
            dynamics.entitySchemas.forEach((item) => {
              if (item.relationshipSourceSchemaId === USERS_SCHEMA.id) {
                relatedSchemasToShow.push(item);
              }
            });
          }

          setPanelsState(
            relatedSchemasToShow.map((schema) => {
              return { name: schema.name, title: schema.name, schema: schema as IEntitySchema };
            })
          );

          if (relatedSchemasToShow && relatedSchemasToShow.length) setActiveTab(relatedSchemasToShow[0].name);
        }

        setLoadingPanels(false);
      } catch (e: any) {
        handleError(e);
        setLoadingPanels(false);
      }
    };

    doAsync();
  }, [entitySchema, dynamics.entitySchemas]);

  useEffect(() => {
    if (!id) return;

    const doAsync = async () => {
      try {
        if (!entitySchema || currentUser.isLoading) return;

        setLoadingData(true);

        if (!currentUser.currentUser) throw new Error('Missing currentUser.currentUser');

        const data: any = await getEntityDataBySchema(
          currentUser.currentUser,
          entitySchema,
          entitySchemaFields,
          id,
          parentEntitySchema,
          parentEntityData
        );

        setEntityData(data);

        setLoadingData(false);
      } catch (e: any) {
        handleError(e);
        setLoadingData(false);
      }
    };

    doAsync();
  }, [entitySchema, id, toggleData, currentUser.isLoading]);

  const handleTabChange = (event: SyntheticEvent, value: string) => {
    setLoadingSchema(true);
    setActiveTab(value);

    router
      .push({
        // pathname: `/apps/user/view/${value.toLowerCase()}`,
        pathname: useCmsRoutes ? `/cms/content/${schemaName}/${id}` : `/${schemaName}/${id}`,
        query: `tab=${value}`,
        // query: `tab=${value.toLowerCase()}`,
      })
      .then(() => setLoadingSchema(false));
  };

  useEffect(() => {
    if (tab && tab !== activeTab) {
      setActiveTab(tab);
    }
  }, [tab]);

  const handleOnEntityEdit = async () => {
    try {
      if (!entitySchema) throw new Error('missing entitySchema');

      const theForm = getEditEntityForm(entitySchema, entitySchemaFields, dynamics);

      setEditEntityForm(theForm);

      setEditSidebarOpen(true);
    } catch (e: any) {
      handleError(e);
    }
  };

  const handleOnEntityDelete = async () => {
    try {
      setLoadingData(true);

      if (!entitySchema || !currentUser.currentUser) throw new Error('Missing entitySchema/currentUser.currentUser');

      await removeEntityDataBySchema(
        currentUser.currentUser,
        entitySchema,
        entitySchemaFields,
        id,

        parentEntitySchema,
        parentEntityData
      );

      // refresco la info
      setToggleData(!toggleData);

      toast.success('successfull removed');

      // cierro sidebar
      setEditSidebarOpen(false);

      // apago loading
      setLoadingData(false);
    } catch (e) {
      setLoadingData(false);
      handleError(e);
    }
  };

  const handleOnEntityRestore = async () => {
    try {
      setLoadingData(true);

      if (!entitySchema || !currentUser.currentUser) throw new Error('Missing entitySchema/currentUser.currentUser');

      await restoreEntityDataBySchema(
        currentUser.currentUser,
        entitySchema,
        entitySchemaFields,
        id,

        parentEntitySchema,
        parentEntityData
      );

      // refresco la info
      setToggleData(!toggleData);

      toast.success('successfull restored');

      // cierro sidebar
      setEditSidebarOpen(false);

      // apago loading
      setLoadingData(false);
    } catch (e) {
      setLoadingData(false);
      handleError(e);
    }
  };

  const handleOnEditSubmit = async (formData: any) => {
    try {
      setLoadingData(true);

      if (
        parentEntityData &&
        (entitySchema?.schemaType === EntitySchemaTypes.RELATIONSHIP_ENTITY ||
          entitySchema?.schemaType === EntitySchemaTypes.ONE_TO_MANY_ENTITY)
      ) {
        const sourceRelationshipField = entitySchemaFields.find((field) => {
          return field.relationshipSchemaId === entitySchema.relationshipSourceSchemaId;
        });

        if (!sourceRelationshipField) throw new Error('Missing field ' + entitySchema.relationshipSourceSchemaId);

        // userId = :id
        formData[sourceRelationshipField.name] = parentEntityData.id;
      }

      if (!entitySchema || !currentUser.currentUser) throw new Error('Missing entitySchema/currentUser.currentUser');

      await updateEntityDataBySchema(
        currentUser.currentUser,
        entitySchema,
        entitySchemaFields,
        id,
        formData,
        parentEntitySchema,
        parentEntityData
      );

      // refresco la tabla
      setToggleData(!toggleData);

      // cierro sidebar
      setEditSidebarOpen(false);

      // apago loading
      setLoadingData(false);
    } catch (e) {
      setLoadingData(false);
      handleError(e);
    }
  };

  const renderLeftPanel = () => {
    if (!entitySchema) return;

    let showAvatar = false;
    const avatarField = entitySchemaFields.find((field) => {
      return field.fieldType === DynamicComponentTypes.FORM_AVATAR;
    });

    let avatarUrl = '';
    let schemaDisplayLabel = '';
    if (avatarField) {
      avatarUrl = entityData[avatarField.name];

      if (entitySchema.fieldNameUsedAsSchemaLabel)
        schemaDisplayLabel = entityData[entitySchema.fieldNameUsedAsSchemaLabel];
    }

    if (avatarField) {
      showAvatar = true;
    } else {
      const userField = entitySchemaFields.find((field) => {
        return field.fieldType === DynamicComponentTypes.USER;
      });

      if (userField) {
        const userDependencyObj = getSourceEntityData({ obj: entityData, key: userField.name }) as IUser;

        if (userDependencyObj) {
          avatarUrl = userDependencyObj.avatarUrl ? userDependencyObj.avatarUrl : '';
          schemaDisplayLabel = capitalize(userDependencyObj.firstName + ' ' + userDependencyObj.lastName);
          showAvatar = true;
        }
      }
    }

    const handleDownloadFile = async (attachment: IAttachment) => {
      if (attachment.downloadURL) window.open(attachment.downloadURL);
      else {
        const downloadUrl = (await getStoredFileDownloadUrl(attachment.refPath)) as any;

        window.open(downloadUrl);
      }
    };

    return (
      <Grid container spacing={6}>
        <Grid item xs={12}>
          <Card>
            {!!showAvatar && (
              <CardContent sx={{ pt: 13.5, display: 'flex', alignItems: 'center', flexDirection: 'column' }}>
                {avatarUrl && (
                  <CustomAvatar src={avatarUrl} variant='rounded' alt={''} sx={{ width: 100, height: 100, mb: 4 }} />
                )}
                {!avatarUrl && showAvatar && schemaDisplayLabel && (
                  <CustomAvatar
                    skin='light'
                    variant='rounded'
                    color={'primary'}
                    sx={{ width: 100, height: 100, mb: 4, fontSize: '3rem' }}
                  >
                    {getInitials(schemaDisplayLabel)}
                  </CustomAvatar>
                )}
                {schemaDisplayLabel && (
                  <Typography variant='h4' sx={{ mb: 3 }}>
                    {schemaDisplayLabel}
                  </Typography>
                )}
              </CardContent>
            )}

            {!!showAvatar && <Divider sx={{ my: '0 !important', mx: 6 }} />}

            <CardContent sx={{ pb: 4 }}>
              <Typography variant='body2' sx={{ color: 'text.disabled', textTransform: 'uppercase' }}>
                Details
              </Typography>
              <Box sx={{ pt: 4 }}>
                {entitySchemaFields.map((field, index) => {
                  if (field.fieldType === DynamicComponentTypes.USER) {
                    return null;
                  }

                  const fieldLabel = field.label;

                  const fieldValue = entityData[field.name];

                  let toRender = fieldValue;

                  if (
                    field.fieldType === DynamicComponentTypes.FORM_MULTI_SELECT_ASYNC ||
                    field.fieldType === DynamicComponentTypes.FORM_SELECT_ASYNC
                  ) {
                    const dependencyObj = getSourceEntityData({ obj: entityData, key: field.name });

                    if (dependencyObj) {
                      if (Array.isArray(dependencyObj)) {
                        toRender = dependencyObj.map((item, index) => {
                          if (field.relationshipSchemaLabelPropName && item[field.relationshipSchemaLabelPropName]) {
                            if (index === dependencyObj.length - 1) return item[field.relationshipSchemaLabelPropName];
                            else return item[field.relationshipSchemaLabelPropName] + ', ';
                          }

                          return '';
                        });
                      } else {
                        if (
                          field.relationshipSchemaLabelPropName &&
                          dependencyObj[field.relationshipSchemaLabelPropName]
                        ) {
                          toRender = dependencyObj[field.relationshipSchemaLabelPropName];
                        }
                      }
                    }
                  } else if (field.fieldType === DynamicComponentTypes.FORM_DATE && fieldValue) {
                    toRender = parseDateToDateTimeString(fieldValue);
                  } else if (field.fieldType === DynamicComponentTypes.ADDRESS && fieldValue) {
                    toRender = (fieldValue as IAddress).addressString;
                  } else if (field.fieldType === DynamicComponentTypes.FILE_UPLOADER && fieldValue) {
                    toRender = (
                      <Icon
                        onClick={() => {
                          handleDownloadFile(fieldValue as IAttachment);
                        }}
                        icon={'tabler:file-check'}
                        fontSize={'1.75rem'}
                        style={{ marginBottom: 8 }}
                        color={'green'}
                      />
                    );
                  } else if (field.fieldType === DynamicComponentTypes.FORM_GENERIC_ANY && fieldValue) {
                    toRender = JSON.stringify(fieldValue);
                  }

                  return (
                    <Box key={index} sx={{ display: 'flex', mb: 3 }}>
                      <Typography sx={{ mr: 2, fontWeight: 500, color: 'text.secondary' }}>{fieldLabel}:</Typography>
                      <Typography sx={{ color: 'text.secondary' }}>{toRender}</Typography>
                    </Box>
                  );
                })}
              </Box>
            </CardContent>

            {entityData.state !== 0 && (
              <CardActions sx={{ display: 'flex', justifyContent: 'center' }}>
                <Button
                  variant='contained'
                  sx={{ mr: 2 }}
                  onClick={() => {
                    handleOnEntityEdit();
                  }}
                >
                  Edit
                </Button>

                <Button
                  variant='contained'
                  color='warning'
                  sx={{ mr: 2 }}
                  onClick={() => {
                    handleOnEntityDelete();
                  }}
                >
                  Delete
                </Button>
              </CardActions>
            )}
          </Card>
        </Grid>
      </Grid>
    );
  };

  const renderRightPanel = () => {
    if (loadingPanels) return <Loader />;

    // si el value de actuve Tab se imprime antes de los tabs estalla el comp
    if (!panelsState || !panelsState.length || !activeTab || !entitySchema) return null;

    console.log('ACTIVE TAB: ' + activeTab);

    return (
      <TabContext value={activeTab}>
        <TabList
          variant='scrollable'
          scrollButtons='auto'
          onChange={handleTabChange}
          aria-label='forced scroll tabs'
          sx={{ borderBottom: (theme) => `1px solid ${theme.palette.divider}` }}
        >
          {panelsState?.map((panel: ILayoutPanel, index) => {
            // return <Tab key={index} value={index === 0 ? FIRST_TAB_KEY : panel.name} label={panel.name} />;
            return (
              <Tab
                key={index}
                value={panel.name}
                label={splitByUppercase(panel.name)}
                sx={{ textTransform: 'capitalize' }}
              />
            );
          })}
        </TabList>

        {/* <TabPanel sx={{ p: 0 }} value={FIRST_TAB_KEY}>

          alkmdasklakds
        </TabPanel> */}

        {panelsState?.map((panel, index) => {
          // if (index === 0) panel.name = FIRST_TAB_KEY;

          console.log('PANEL CONTENT: ' + panel.name);

          return (
            <TabPanel key={index} sx={{ p: 0 }} value={panel.name}>
              <DynamicSchemaLayoutEditTabContent
                panel={panel}
                docId={id}
                parentEntitySchema={parentEntitySchema ? parentEntitySchema : entitySchema}
                parentEntityData={parentEntityData ? parentEntityData : entityData}
              />
            </TabPanel>
          );
        })}
      </TabContext>
    );
  };

  if (!dynamics.entitySchemas || !dynamics.entitySchemasFields) return <Loader />;

  if (loadingSchema || loadingData || loadingPanels) return <Loader />;

  if (!entityData) return <>Error loading data</>;

  // default layout...
  return (
    <Grid container spacing={6}>
      <Grid item xs={12} md={12} lg={12}>
        <Card>
          {/* <CardContent sx={{ pt: 0, display: 'flex', alignItems: 'left', flexDirection: 'column' }}>back</CardContent> */}
          <IconButton
            color='inherit'
            onClick={() => {
              // TODO Hacer HistoryContext
              const splittedUrl = router.asPath.split('/');

              const backRoute = splittedUrl.reduce((prev, curr, index) => {
                if (index === splittedUrl.length - 2) return prev;

                return prev + '/' + curr;
              });

              router.push(backRoute);
            }}
          >
            <Icon fontSize='1.625rem' icon='tabler:arrow-badge-left-filled' />
          </IconButton>
          {entityData.state === 0 && (
            <Alert
              severity='warning'
              action={
                <Button
                  color='inherit'
                  size='small'
                  onClick={() => {
                    handleOnEntityRestore();
                  }}
                >
                  Undo
                </Button>
              }
            >
              <AlertTitle>This entity is deleted!</AlertTitle>
            </Alert>
          )}
        </Card>
      </Grid>

      <Grid
        item
        xs={12}
        md={!panelsState || !panelsState.length ? 12 : 5}
        lg={!panelsState || !panelsState.length ? 12 : 4}
      >
        {renderLeftPanel()}
      </Grid>
      <Grid item xs={12} md={7} lg={8}>
        {renderRightPanel()}
      </Grid>

      {!!editSidebarOpen && (
        <DynamicFormSidebar
          isCreating={false}
          onSubmit={handleOnEditSubmit}
          title={'Edit ' + entitySchema?.name}
          formId={'Edit_' + entitySchema?.name}
          initialValues={entityData}
          preloadForm={editEntityForm}
          open={editSidebarOpen}
          toggle={toggleEditDrawer}
          onSubmitDone={() => {
            toggleEditDrawer();

            return Promise.resolve();
          }}
        />
      )}
    </Grid>
  );
};

export default DynamicSchemaLayoutEdit;
