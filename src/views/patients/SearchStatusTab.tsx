// ** MUI Imports
import Card from '@mui/material/Card';
import CardContent from '@mui/material/CardContent';
import CardHeader from '@mui/material/CardHeader';
import Grid from '@mui/material/Grid';
import { useTranslation } from 'react-i18next';
// ** Custom Components Imports
import { Button, Divider, Icon, MenuItem, Slider, Typography, capitalize } from '@mui/material';
import { useEffect, useState } from 'react';
import { getSourceEntityData, handleError, nameof, hasRole, DISTANCE_OPTIONS } from 'src/@core/coreHelper';
import {
  CMSCollections,
  IAddress,
  IPatient,
  IUserBasicData,
  IUsersAddress,
  IWorker,
  WorkerStateTypes,
} from 'src/types/@autogenerated';
import { useCurrentUser } from 'src/hooks/useCurrentUser';
import { UserDefinedRols } from 'src/types/userDefinedRols';
import { AppRols } from 'src/types/appRols';
import FormLocationField from 'src/@core/components/form/FormLocationField';
import Loader from 'src/@core/components/loader';
import { dynamicGet, dynamicUpdate } from 'src/services/entitiesDynamicServices';
import { IUserAddressGeoqueryItem } from 'src/types/addresses';
import Box from '@mui/system/Box';
import TextInfo from 'src/@core/components/custom-text-info';
import CustomTextField from 'src/@core/components/mui/text-field';

const DEFAULT_KILOMETERS = [
  {
    value: 5,
    label: '5K',
  },
  {
    value: 10,
    label: '10K',
  },
  {
    value: 20,
    label: '20K',
  },
  {
    value: 50,
    label: '50K',
  },
];

interface PropsType {
  docId: string;
  patient: IPatient;
  addresses: IUsersAddress[];
}

interface IMarkerData {
  firstName: string;
  lastName: string;

  address: IAddress;

  iconColor: string;
  workerState?: string;
  stateColor: string;
  nearWorkers?: number;
  isPatient: boolean;
}

const SearchStatusTab = ({ docId, patient, addresses }: PropsType) => {
  // ** Hooks
  const { t } = useTranslation();
  const win: any = window;

  // ** State
  const [map, setMap] = useState<any>(null);
  const [isLoading, setIsLoading] = useState<boolean>(true);

  const [closeWorkersFromPatient, setCloseWorkersFromPatient] = useState<IUserAddressGeoqueryItem[]>([]);
  const [distanceOptions, setDistanceOptions] =
    useState<{ label: string; value: string; raw: any }[]>(DISTANCE_OPTIONS);
  const [selectedDistanceOption, setSelectedDistanceOption] = useState<{ label: string; value: string; raw: any }>(
    DISTANCE_OPTIONS[1]
  );

  const [markers, setMarkers] = useState<any[]>([]);

  let initialAddress = null;

  if (addresses && addresses.length) {
    initialAddress = addresses.find((address) => {
      return address.isPrimary;
    });
    if (!initialAddress) initialAddress = addresses[0];
  }

  const [selectedAddress, setSelectedAddress] = useState<IUsersAddress | null>(initialAddress);

  const workersInProcessStates = [
    WorkerStateTypes.PENDING_AVAILABILITY,
    WorkerStateTypes.PENDING_DOCS,
    WorkerStateTypes.PENDING_EXPERIENCE,
    WorkerStateTypes.PENDING_GENERAL_INFO,
    WorkerStateTypes.PENDING_INTERVIEW,
    WorkerStateTypes.PENDING_PREFERENCES,
  ];

  useEffect(() => {
    const doAsync = async () => {
      try {
        setIsLoading(true);

        if (!patient) return;

        // remove current markers
        if (markers) {
          markers.forEach((marker) => {
            marker.setMap(null);
          });
        }

        if (selectedAddress?.address) {
          const toleranceDistanceInMts = parseInt(selectedDistanceOption.value) * 1000;

          const geoqueryResults = (await dynamicGet({
            params: `/cms/geo-query-user-addresses/${selectedAddress?.address?.lat}/${selectedAddress?.address?.lng}/${toleranceDistanceInMts}`,
          })) as IUserAddressGeoqueryItem[];

          const addressesWithWorkersData: IUserAddressGeoqueryItem[] = [];

          geoqueryResults.forEach((item: IUserAddressGeoqueryItem) => {
            const workerData = getSourceEntityData({
              obj: item,
              key: nameof<IUserAddressGeoqueryItem>('workerId'),
            }) as IWorker;

            if (!workerData) return;

            if (!workerData.state) return;

            addressesWithWorkersData.push({ ...item, worker: workerData });
          });

          setCloseWorkersFromPatient(addressesWithWorkersData);
        }

        setIsLoading(false);
      } catch (e) {
        setIsLoading(false);
        handleError(e);
      }
    };

    doAsync();
  }, [patient, selectedDistanceOption, selectedAddress]);

  function addInfoWindow(marker: any, message: any) {
    const infoWindow = new win.google.maps.InfoWindow({
      content: message,
    });

    win.google.maps.event.addListener(marker, 'click', function () {
      infoWindow.open(map, marker);
    });
  }

  useEffect(() => {
    if (!map || !closeWorkersFromPatient || !patient || !selectedAddress) return;

    const bounds = new win.google.maps.LatLngBounds();

    const markersData: IMarkerData[] = []; // patients.merge(workers);

    const MINIMUM_QUANTITY_OF_WORKERS = 5;
    const TOLERANCE_WORKER_QUANTITY_FOR_PATIENTS = 10;

    const basicPatientMarkerData = {
      firstName: patient.firstName,
      lastName: patient.firstName,
      address: selectedAddress.address,
      nearWorkers: closeWorkersFromPatient.length,
      isPatient: true,
    };

    if (closeWorkersFromPatient.length >= TOLERANCE_WORKER_QUANTITY_FOR_PATIENTS) {
      markersData.push({
        ...basicPatientMarkerData,

        iconColor: '#28C76F',
        stateColor: '#28C76F',
      });
    } else if (
      closeWorkersFromPatient.length >= MINIMUM_QUANTITY_OF_WORKERS &&
      closeWorkersFromPatient.length < TOLERANCE_WORKER_QUANTITY_FOR_PATIENTS
    ) {
      markersData.push({
        ...basicPatientMarkerData,

        iconColor: '#FF9F43',
        stateColor: '#FF9F43',
      });
    } else {
      markersData.push({
        ...basicPatientMarkerData,

        iconColor: '#EA5455',
        stateColor: '#EA5455',
      });
    }

    // agrego los workers como markers
    closeWorkersFromPatient.forEach((item) => {
      const worker = item.worker;
      if (!worker) return;

      if (worker.workerState && workersInProcessStates.includes(worker.workerState)) {
        markersData.push({
          firstName: worker.firstName,
          lastName: worker.lastName,
          address: item.address,

          iconColor: '#FF9F43',
          workerState: 'in process',
          stateColor: '#FF9F43',
          isPatient: false,
        });
      } else {
        markersData.push({
          firstName: worker.firstName,
          lastName: worker.lastName,
          address: item.address,

          iconColor: '#00CFE8',
          workerState: worker.workerState,
          stateColor: '#28C76F',
          isPatient: false,
        });
      }
    });

    const googleMarkers: any[] = [];

    markersData.forEach((markerData: IMarkerData) => {
      const marker = new win.google.maps.Marker();

      googleMarkers.push(marker);

      const address = markerData.address;
      if (
        !address ||
        !address.addressObject ||
        !address.addressObject.geometry ||
        !address.addressObject.geometry.location
      )
        return;

      const svgMarker = {
        path: 'M-1.547 12l6.563-6.609-1.406-1.406-5.156 5.203-2.063-2.109-1.406 1.406zM0 0q2.906 0 4.945 2.039t2.039 4.945q0 1.453-0.727 3.328t-1.758 3.516-2.039 3.070-1.711 2.273l-0.75 0.797q-0.281-0.328-0.75-0.867t-1.688-2.156-2.133-3.141-1.664-3.445-0.75-3.375q0-2.906 2.039-4.945t4.945-2.039z',
        fillColor: markerData.iconColor,
        fillOpacity: 0.8,
        strokeWeight: 0,
        rotation: 0,
        scale: 2,
        anchor: new win.google.maps.Point(0, 20),
      };

      let showInfo = `<div>
          <h3 style="font-size: 10; color: black !important;">
          ${capitalize(markerData.firstName) + ' ' + capitalize(markerData.lastName)}
          </h3>`;
      if (markerData.workerState) {
        showInfo += `
          <div class="box-container" key="idx" style="display: flex; align-items: center;">
            <svg class="svg-icon" style="color: ${markerData.stateColor}; height: 15px; width: 15px">
              <circle cx="0.375rem" cy="0.375rem" r="0.375rem" fill="currentColor" />
            </svg>
            <span class="typography-text" style="color:black">
              ${capitalize(t(markerData.workerState))}
            </span>
          </div>
        </div>`;
      } else {
        showInfo += `
        <div class="box-container" key="idx" style="display: flex; align-items: center;">
        <svg class="svg-icon" style="color: ${markerData.stateColor}; height: 15px; width: 15px">
          <circle cx="0.375rem" cy="0.375rem" r="0.375rem" fill="currentColor" />
        </svg>
        <span class="typography-text" style="color:black">
          ${markerData.nearWorkers} ${capitalize(t('workers nearby'))}
        </span>
      </div>
        </div>`;
      }

      marker.setOptions({
        position: address.addressObject.geometry.location,
        draggable: false,
        map: map,
        icon: markerData.isPatient ? null : svgMarker,
      });

      addInfoWindow(marker, showInfo);
    });

    setMarkers(googleMarkers);
    let max_latitude = -400,
      min_latitude = 400,
      max_longitude = -400,
      min_logitude = 400;

    markersData.forEach((markerData) => {
      if (!markerData.address.lat || !markerData.address.lng) return;

      if (max_latitude < markerData.address.lat) max_latitude = markerData.address.lat;
      if (min_latitude > markerData.address.lat) min_latitude = markerData.address.lat;
      if (max_longitude < markerData.address?.lng) max_longitude = markerData.address?.lng;
      if (min_logitude > markerData.address?.lng) min_logitude = markerData.address?.lng;
    });

    const latitude = (max_latitude + min_latitude) / 2;
    const longitude = (max_longitude + min_logitude) / 2;
    // const latitude = Math.abs((max_latitude - (max_latitude + min_latitude) / 2) * 3);
    // const longitude = Math.abs((max_longitude - (max_longitude + min_logitude) / 2) * 3);

    bounds.extend({
      lat: latitude,
      lng: longitude,
    });

    map.fitBounds(bounds);

    // map.setOptions({ maxZoom: 17 });

    // const listener = win.google.maps.event.addListener(map, 'idle', function () {
    map.setZoom(12);
    //   win.google.maps.event.removeListener(listener);
    // });
  }, [map, patient, closeWorkersFromPatient]);

  useEffect(() => {
    if (!win.google) return;

    const mapAux = new win.google.maps.Map(document.getElementById('map-canvas'), {
      center: {
        lat: -33.40338,
        lng: -65.17403,
      },
      zoom: 4,
    });

    // if (!marker) setMarker(new win.google.maps.Marker());

    // if (!circle) setCircle(new win.google.maps.Circle());

    setMap(mapAux);
  }, [win.google]);

  return (
    <>
      {!isLoading && (
        <Card style={{ marginBottom: 10, marginTop: 10 }}>
          <CardHeader title={capitalize(t('search'))} />
          <CardContent>
            <Grid container spacing={0}>
              <Grid item xs={12}>
                <CustomTextField
                  select
                  fullWidth
                  label={t('Patient address')}
                  onChange={(event) => {
                    const selected = addresses.find((address) => {
                      return address.id === event.target.value;
                    });
                    if (selected) setSelectedAddress(selected);
                  }}
                  value={selectedAddress?.id}
                >
                  {!!addresses &&
                    addresses.map((op, index) => {
                      return (
                        <MenuItem key={index} value={op.id}>
                          {/* <em>None</em> */}
                          {op.address.addressString}
                        </MenuItem>
                      );
                    })}
                </CustomTextField>
              </Grid>

              <Grid item xs={12}>
                <CustomTextField
                  select
                  fullWidth
                  label={t('distance in km')}
                  onChange={(event) => {
                    const selected = distanceOptions.find((op) => {
                      return op.value === event.target.value;
                    });
                    if (selected) setSelectedDistanceOption(selected);
                  }}
                  value={selectedDistanceOption.value}
                >
                  {!!distanceOptions &&
                    distanceOptions.map((op, index) => {
                      return (
                        <MenuItem key={index} value={op.value}>
                          {/* <em>None</em> */}
                          {op.label}
                        </MenuItem>
                      );
                    })}
                </CustomTextField>
              </Grid>
            </Grid>
            <Grid container spacing={0}>
              <Grid item xs={12}>
                {/* <Divider sx={{ m: '0 !important' }} /> */}

                <Grid sx={{ ml: 2 }}>
                  <Grid container spacing={4}>
                    <Grid item xs={12} md={6}>
                      <TextInfo title={'Trabajadores cercanos'} value={closeWorkersFromPatient.length} />
                    </Grid>
                    <Grid item xs={12} md={6}>
                      <TextInfo
                        title={'Trabajadores cercanos y activos'}
                        value={
                          closeWorkersFromPatient.filter((item) => {
                            return (
                              item.worker?.workerState && !workersInProcessStates.includes(item.worker.workerState)
                            );
                          }).length
                        }
                      ></TextInfo>
                    </Grid>
                  </Grid>
                </Grid>
              </Grid>
            </Grid>
          </CardContent>
        </Card>
      )}
      <Card>
        <CardContent>
          <Grid container spacing={0}>
            <Grid item xs={12}>
              <Card>
                {/* <Divider sx={{ m: '0 !important' }} /> */}
                {isLoading && <Loader />}

                <div id='map-canvas' style={{ height: 390 }} />
              </Card>
            </Grid>
          </Grid>
        </CardContent>
      </Card>
    </>
  );
};

export default SearchStatusTab;
