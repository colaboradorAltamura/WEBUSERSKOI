// ** MUI Imports
import Card from '@mui/material/Card';
import CardContent from '@mui/material/CardContent';
import CardHeader from '@mui/material/CardHeader';
import Grid from '@mui/material/Grid';
import { ReactElement, Ref, forwardRef, useEffect, useState } from 'react';
import { useTranslation } from 'react-i18next';
// ** Custom Components Imports
import { MenuItem, capitalize } from '@mui/material';
import Box from '@mui/material/Box';
import Dialog from '@mui/material/Dialog';
import DialogContent from '@mui/material/DialogContent';
import Fade, { FadeProps } from '@mui/material/Fade';
import IconButton, { IconButtonProps } from '@mui/material/IconButton';
import { styled } from '@mui/material/styles';
import Loader from 'src/@core/components/loader';
import CustomTextField from 'src/@core/components/mui/text-field';
import { getSourceEntityData, handleError, nameof } from 'src/@core/coreHelper';
import { useCurrentUser } from 'src/hooks/useCurrentUser';
import { useDynamics } from 'src/hooks/useDynamics';
import { dynamicGet } from 'src/services/entitiesDynamicServices';
import { IKanbanBoard, IKanbanBoardCard } from 'src/types';
import {
  CMSCollections,
  IOpenPosition,
  IOpenPositionWorker,
  IPatient,
  IUsersAddress,
  IWorker,
  OpenPositionAsignmentStatusTypes,
} from 'src/types/@autogenerated';
import { IForm } from 'src/types/dynamics';
import { IEntitySchema, IEntitySchemaField, IEntitySchemaWithFields } from 'src/types/entities';
import DynamicFormSidebar from '../components/dynamics/DynamicFormSidebar';
import { createEntityDataBySchema, schemaToForm, updateEntityDataBySchema } from '../components/dynamics/helpers';
import KanbanBoards from './kanban';
import Icon from 'src/@core/components/icon';
import Typography from '@mui/material/Typography';
import WorkerSearch from '../workersSearch';
import TextInfo from 'src/@core/components/custom-text-info';

interface PropsType {
  docId: string;
  patient: IPatient;
  addresses: IUsersAddress[];
}

const TherapeuticMatchTab = ({ docId, patient, addresses }: PropsType) => {
  // ** Hooks
  const { t } = useTranslation();
  const dynamics = useDynamics();
  const currentUser = useCurrentUser();

  // ** State
  const [toggleData, setToggleData] = useState<boolean>(false);

  const [entitySchema, setEntitySchema] = useState<IEntitySchema | null>(null);
  const [entitySchemaFields, setEntitySchemaFields] = useState<IEntitySchemaField[]>([]);
  const [loadingSchema, setLoadingSchema] = useState<boolean>(true);

  const [isLoading, setIsLoading] = useState<boolean>(true);

  const [patientOpenPosition, setPatientOpenPosition] = useState<IOpenPosition | null>(null);

  const [openPositionWorkers, setOpenPositionWorkers] = useState<IOpenPositionWorker[]>([]);
  const [kanbanCards, setKanbanCards] = useState<IKanbanBoardCard[]>([]);

  const [openPositionWorkerSidebarForm, setOpenPositionWorkerSidebarForm] = useState<IForm | null>(null);
  const [openPositionWorkerSidebarOpen, setOpenPositionWorkerSidebarOpen] = useState<boolean>(false);
  const [selectedOpenPositionWorker, setSelectedOpenPositionWorker] = useState<IOpenPositionWorker | null>(null);

  const [selectedBoard, setSelectedBoard] = useState<IKanbanBoard | null>(null);
  const [showAddWorkerModal, setShowAddWorkerModal] = useState<boolean>(false);

  const toggleWorkertDrawer = () => setOpenPositionWorkerSidebarOpen(!openPositionWorkerSidebarOpen);
  const toggleShowAddWorkerModal = () => setShowAddWorkerModal(!showAddWorkerModal);

  const handleOnCardClick = (card: IKanbanBoardCard) => {
    try {
      if (card.isLoading) return;

      const openPositionWorker = openPositionWorkers.find((opw) => {
        return opw.id === card.id;
      });

      if (!openPositionWorker) throw new Error('invalid id');

      setSelectedOpenPositionWorker(openPositionWorker);
      setOpenPositionWorkerSidebarOpen(true);
    } catch (e) {
      handleError(e);
    }
  };

  const handleOnWorkerOpenPositionSubmit = async (formData: IOpenPositionWorker) => {
    try {
      if (!selectedOpenPositionWorker) return;

      if (!entitySchema) throw new Error('missing entitySchema');
      if (!currentUser.currentUser) throw new Error('missing currentUser.currentUser');
      if (!formData.id) throw new Error('missing formData.id');

      const selectedKanbanCard = kanbanCards.find((kanbanCard) => {
        return kanbanCard.id === selectedOpenPositionWorker.id;
      });

      if (!selectedKanbanCard) throw new Error('missing selectedKanbanCard');

      setOpenPositionWorkerSidebarOpen(false);

      selectedKanbanCard.isLoading = true;
      selectedKanbanCard.boardId = formData.assignmentStatus;

      setKanbanCards([...kanbanCards]);

      await updateEntityDataBySchema(
        currentUser.currentUser,
        entitySchema,
        entitySchemaFields,
        formData.id,
        formData,
        null,
        null
      );

      // cierro sidebar

      // apago loading
      selectedKanbanCard.isLoading = false;

      setKanbanCards([...kanbanCards]);
    } catch (e) {
      // setLoadingData(false);
      handleError(e);
    }
  };

  const handleOnAddCard = async (board: IKanbanBoard) => {
    setSelectedBoard(board);
    setShowAddWorkerModal(true);
  };

  const handleOnWorkerSelected = async (worker: IWorker) => {
    try {
      setIsLoading(true);
      toggleShowAddWorkerModal();

      if (!entitySchema) throw new Error('missing entitySchema');
      if (!currentUser.currentUser) throw new Error('missing currentUser.currentUser');
      if (!worker.id) throw new Error('missing worker.id');
      if (!patientOpenPosition?.id) throw new Error('missing patientOpenPosition?.id');

      const existent = openPositionWorkers.find((item) => {
        return item.userId === worker.id;
      });

      if (existent) throw new Error('Worker already exists');

      const formData: IOpenPositionWorker = {
        // order?: number;
        assignmentStatus: selectedBoard?.id as OpenPositionAsignmentStatusTypes,
        userId: worker.id,
        openPositionId: patientOpenPosition?.id,
      };

      await createEntityDataBySchema(currentUser.currentUser, entitySchema, entitySchemaFields, formData, null, null);

      setIsLoading(false);

      setToggleData(!toggleData);
    } catch (e) {
      setIsLoading(false);
      handleError(e);
    }
  };

  let initialAddress = null;

  if (addresses && addresses.length) {
    initialAddress = addresses.find((address) => {
      return address.isPrimary;
    });
    if (!initialAddress) initialAddress = addresses[0];
  }

  const [selectedAddress, setSelectedAddress] = useState<IUsersAddress | null>(initialAddress);

  const processAndSetOpenPositionWorkerForm = async () => {
    if (!entitySchema?.id) throw new Error('missing id');

    const entitySchemaResponse: IEntitySchemaWithFields = { ...entitySchema, fields: entitySchemaFields };

    const fieldsNames = [nameof<IOpenPositionWorker>('assignmentStatus')];

    const toShowFields = entitySchemaFields.filter((field) => {
      return fieldsNames.includes(field.name);
    });

    const theForm = schemaToForm(entitySchemaResponse, toShowFields, null, dynamics);

    setOpenPositionWorkerSidebarForm(theForm);
  };

  // fetch schema
  useEffect(() => {
    const doAsync = async () => {
      try {
        setLoadingSchema(true);

        if (dynamics.isLoadingSchemas || !dynamics.entitySchemas || !dynamics.entitySchemasFields) return null;

        const schema = dynamics.entitySchemas.find((schema) => {
          return schema.name === CMSCollections.OPEN_POSITION_WORKERS;
        });
        if (!schema) throw new Error('Missing schemaName: ' + CMSCollections.OPEN_POSITION_WORKERS);
        const schemaFields = dynamics.entitySchemasFields.filter((field) => {
          return field.schemaId === schema.id;
        });

        // Fetch Schema
        //const entitySchemaResponse = (await getEntitySchemaByName(schemaName)) as IEntitySchemaWithFields;
        const entitySchemaResponse: IEntitySchemaWithFields = { ...schema, fields: schemaFields };

        setEntitySchema(entitySchemaResponse);

        // Fetch Fields
        // const entitySchemaFieldsResponse = await listEntitySchemaFields(entitySchemaResponse.id);

        setEntitySchemaFields(
          entitySchemaResponse.fields.sort((a, b) => {
            return a.order - b.order;
          })
        );

        setLoadingSchema(false);
      } catch (e: any) {
        handleError(e);
        setLoadingSchema(false);
      }
    };

    doAsync();
  }, [dynamics.isLoadingSchemas]);

  useEffect(() => {
    if (!patient || loadingSchema) return;

    const doAsync = async () => {
      try {
        if (!patient) return;

        setIsLoading(true);

        const patientOpenPositionResult = (await dynamicGet({
          params: `/cms/${CMSCollections.OPEN_POSITIONS}/by-prop/${nameof<IOpenPosition>('patient')}/${patient.id}`,
        })) as { items: IOpenPosition[] };
        if (!patientOpenPositionResult || !patientOpenPositionResult.items || !patientOpenPositionResult.items.length) {
          throw new Error('Missing open position for patient: ' + patient.id);
        }

        const openPositionWorkersResult = (await dynamicGet({
          params: `/cms/${CMSCollections.OPEN_POSITION_WORKERS}/by-prop/${nameof<IOpenPositionWorker>(
            'openPositionId'
          )}/${patientOpenPositionResult.items[0].id}`,
        })) as { items: IOpenPositionWorker[] };

        setPatientOpenPosition(patientOpenPositionResult.items[0]);
        setOpenPositionWorkers(openPositionWorkersResult.items);

        const cards: IKanbanBoardCard[] = openPositionWorkersResult.items.map((opWorker) => {
          const relatedWorker = getSourceEntityData({
            obj: opWorker,
            key: nameof<IOpenPositionWorker>('userId'),
          }) as IWorker;

          if (!relatedWorker) throw new Error('missing relatedWorker for open position: ' + opWorker.id);

          return {
            id: opWorker.id,
            boardId: opWorker.assignmentStatus,
            order: opWorker.order,
            rawData: opWorker,

            title: relatedWorker.firstName + ' ' + relatedWorker.lastName,
          } as IKanbanBoardCard;
        });

        setKanbanCards(cards);

        await processAndSetOpenPositionWorkerForm();
        setIsLoading(false);
      } catch (e) {
        setIsLoading(false);
        handleError(e);
      }
    };

    doAsync();
  }, [loadingSchema, toggleData]);

  if (isLoading) return <Loader />;

  const boards: IKanbanBoard[] = [
    { id: OpenPositionAsignmentStatusTypes.INTERESTED, title: t(OpenPositionAsignmentStatusTypes.INTERESTED) },
    { id: OpenPositionAsignmentStatusTypes.PRE_SELECTED, title: t(OpenPositionAsignmentStatusTypes.PRE_SELECTED) },
    { id: OpenPositionAsignmentStatusTypes.INTERVIEWED, title: t(OpenPositionAsignmentStatusTypes.INTERVIEWED) },
    { id: OpenPositionAsignmentStatusTypes.SELECTED, title: t(OpenPositionAsignmentStatusTypes.SELECTED) },
  ];

  const CustomCloseButton = styled(IconButton)<IconButtonProps>(({ theme }) => ({
    top: 0,
    right: 0,
    color: 'grey.500',
    position: 'absolute',
    boxShadow: theme.shadows[2],
    transform: 'translate(10px, -10px)',
    borderRadius: theme.shape.borderRadius,
    backgroundColor: `${theme.palette.background.paper} !important`,
    transition: 'transform 0.25s ease-in-out, box-shadow 0.25s ease-in-out',
    '&:hover': {
      transform: 'translate(7px, -5px)',
    },
  }));

  const Transition = forwardRef(function Transition(
    props: FadeProps & { children?: ReactElement<any, any> },
    ref: Ref<unknown>
  ) {
    return <Fade ref={ref} {...props} />;
  });

  const handleClose = () => {
    setShowAddWorkerModal(false);
  };

  return (
    <>
      <Card style={{ marginBottom: 10, marginTop: 10 }}>
        <CardHeader title={capitalize(t('Patient data'))} />
        <CardContent>
          <Grid container spacing={0}>
            <Grid item xs={12}>
              <TextInfo title={'pathologies types'} value={patientOpenPosition?.pathologyType}></TextInfo>
            </Grid>
            <Grid item xs={12}>
              <TextInfo title={'age range'} value={patientOpenPosition?.agePreference}></TextInfo>
            </Grid>
            <Grid item xs={12}>
              <TextInfo title={'worker amount'} value={patientOpenPosition?.workerAmount}></TextInfo>
            </Grid>
            <Grid item xs={12}>
              <TextInfo title={'worker types'} value={patientOpenPosition?.workerTypes}></TextInfo>
            </Grid>
            <Grid item xs={12}>
              <TextInfo title={'sex'} value={patientOpenPosition?.workerSex}></TextInfo>
            </Grid>
            <Grid item xs={12}>
              <TextInfo title={'profile'} value={patientOpenPosition?.workerProfile}></TextInfo>
            </Grid>
            <Grid item xs={12}>
              <TextInfo title={'worker attributes'} value={patientOpenPosition?.workerAttributes}></TextInfo>
            </Grid>
            <Grid item xs={12}>
              <CustomTextField
                select
                fullWidth
                label={t('Patient address')}
                onChange={(event) => {
                  const selected = addresses.find((address) => {
                    return address.id === event.target.value;
                  });
                  if (selected) setSelectedAddress(selected);
                }}
                value={selectedAddress?.id}
              >
                {!!addresses &&
                  addresses.map((op, index) => {
                    return (
                      <MenuItem key={index} value={op.id}>
                        {/* <em>None</em> */}
                        {op.address.addressString}
                      </MenuItem>
                    );
                  })}
              </CustomTextField>
            </Grid>
          </Grid>
        </CardContent>
      </Card>

      <Card>
        <CardContent>
          <Grid container spacing={0}>
            <Grid item xs={12}>
              {/* <Divider sx={{ m: '0 !important' }} /> */}
              {isLoading && <Loader />}

              <KanbanBoards
                boards={boards}
                cards={kanbanCards}
                onCardClick={handleOnCardClick}
                onAddCard={handleOnAddCard}
              />
            </Grid>
          </Grid>
        </CardContent>
      </Card>

      {!!openPositionWorkerSidebarOpen && (
        <DynamicFormSidebar
          isCreating={false}
          onSubmit={handleOnWorkerOpenPositionSubmit}
          title={'Edit'}
          formId={'Edit_' + 'workerOpenPosition'}
          initialValues={selectedOpenPositionWorker}
          preloadForm={openPositionWorkerSidebarForm}
          open={openPositionWorkerSidebarOpen}
          toggle={toggleWorkertDrawer}
          onSubmitDone={() => {
            toggleWorkertDrawer();

            return Promise.resolve();
          }}
        />
      )}

      <Dialog
        fullWidth
        open={showAddWorkerModal}
        scroll='body'
        maxWidth='md'
        onClose={handleClose}
        onBackdropClick={handleClose}
        TransitionComponent={Transition}
        sx={{ '& .MuiDialog-paper': { overflow: 'visible' } }}
      >
        <DialogContent
          sx={{
            pr: (theme) => [`${theme.spacing(5)} !important`, `${theme.spacing(15)} !important`],
            pl: (theme) => [`${theme.spacing(5)} !important`, `${theme.spacing(11)} !important`],
            py: (theme) => [`${theme.spacing(8)} !important`, `${theme.spacing(12.5)} !important`],
          }}
        >
          <CustomCloseButton onClick={handleClose}>
            <Icon icon='tabler:x' fontSize='1.25rem' />
          </CustomCloseButton>
          <Box sx={{ mb: 8, textAlign: 'center' }}>
            {selectedBoard && (
              <Typography variant='h5' sx={{ mb: 3 }}>
                Add to board {capitalize(t(selectedBoard.title))}
              </Typography>
            )}
          </Box>
          <Box sx={{ display: 'flex', flexWrap: { xs: 'wrap', md: 'nowrap' } }}>
            <WorkerSearch
              onWorkerSelected={handleOnWorkerSelected}
              addresses={addresses}
              initialAddress={selectedAddress}
            />
          </Box>
        </DialogContent>
      </Dialog>
    </>
  );
};

export default TherapeuticMatchTab;
