// ** MUI Imports
import Card from '@mui/material/Card';
import CardContent from '@mui/material/CardContent';
import CardHeader from '@mui/material/CardHeader';
import Grid from '@mui/material/Grid';
import { useTranslation } from 'react-i18next';
// ** Custom Components Imports
import { Button, Divider, Slider, Typography, capitalize } from '@mui/material';
import { useEffect, useState } from 'react';
import { getSourceEntityData, handleError, nameof, hasRole } from 'src/@core/coreHelper';
import {
  CMSCollections,
  IAddress,
  IPatient,
  IUserBasicData,
  IUsersAddress,
  IWorker,
  WorkerStateTypes,
} from 'src/types/@autogenerated';
import { useCurrentUser } from 'src/hooks/useCurrentUser';
import { UserDefinedRols } from 'src/types/userDefinedRols';
import { AppRols } from 'src/types/appRols';
import FormLocationField from 'src/@core/components/form/FormLocationField';
import Loader from 'src/@core/components/loader';
import { dynamicGet, dynamicUpdate } from 'src/services/entitiesDynamicServices';

const DEFAULT_KILOMETERS = [
  {
    value: 5,
    label: '5K',
  },
  {
    value: 10,
    label: '10K',
  },
  {
    value: 20,
    label: '20K',
  },
  {
    value: 50,
    label: '50K',
  },
];

interface PropsType {
  defaultDistance?: number;
  kilometers?: any;
  title?: string;
}

interface IUserWithMarkerData extends IUserBasicData {
  iconColor: string;
  workerState?: string;
  stateColor: string;
  nearWorkers?: number;
}

interface IListResponseWorkers {
  total: number;
  hasMore: boolean;
  items: IWorker[];
}

interface IListResponsePatients {
  total: number;
  hasMore: boolean;
  items: IPatient[];
}
const RecruitmentMap = ({ defaultDistance, kilometers, title }: PropsType) => {
  // ** Hooks
  const { t } = useTranslation();
  const currentUser = useCurrentUser();
  const win: any = window;

  // ** State
  const [map, setMap] = useState<any>(null);
  const [marker, setMarker] = useState<any>();
  const [circle, setCircle] = useState<any>();
  // const [addressPlace, setAddressPlace] = useState<any>(primaryAddress ?? null);
  //const [addressData, setAddressData] = useState<IUsersAddress | null>(primaryAddress);
  const [loading, setLoading] = useState<boolean>(false);
  const [radioDistance, setRadioDistance] = useState<number>(defaultDistance ?? 5000);
  const [marks, setMarks] = useState<any>(kilometers ?? DEFAULT_KILOMETERS);
  const [patients, setPatients] = useState<IPatient[] | null>(null);
  const [workers, setWorkers] = useState<IWorker[] | null>(null);
  const isPermittedByRol = () => {
    return (
      !currentUser.isLoading &&
      !!currentUser.currentUser &&
      (hasRole(currentUser.currentUser?.appRols, AppRols.APP_ADMIN) ||
        hasRole(currentUser.currentUser?.userDefinedRols, UserDefinedRols.UDR_STAFF_RECRUITER))
    );
  };

  const deg2rad = (deg: any) => {
    return deg * (Math.PI / 180);
  };

  const getDistanceFromLatLonInKm = (lat1: any, lon1: any, lat2: any, lon2: any) => {
    const R = 6371; // Radius of the earth in km
    const dLat = deg2rad(lat2 - lat1); // deg2rad below
    const dLon = deg2rad(lon2 - lon1);
    const a =
      Math.sin(dLat / 2) * Math.sin(dLat / 2) +
      Math.cos(deg2rad(lat1)) * Math.cos(deg2rad(lat2)) * Math.sin(dLon / 2) * Math.sin(dLon / 2);
    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
    const d = R * c; // Distance in km
    console.log('Distancia: ', d);

    return d;
  };

  const workersInProcessStates = [
    WorkerStateTypes.PENDING_AVAILABILITY,
    WorkerStateTypes.PENDING_DOCS,
    WorkerStateTypes.PENDING_EXPERIENCE,
    WorkerStateTypes.PENDING_GENERAL_INFO,
    WorkerStateTypes.PENDING_INTERVIEW,
    WorkerStateTypes.PENDING_PREFERENCES,
  ];
  useEffect(() => {
    const doAsync = async () => {
      try {
        const workersResponse = (await dynamicGet({
          params: '/cms/' + CMSCollections.WORKERS,
          filters: [
            {
              key: 'workerState',
              value: [WorkerStateTypes.INACTIVE],
              operator: '$notin',
            },
          ],
        })) as IListResponseWorkers;

        const patientsResponse = (await dynamicGet({
          params: '/cms/' + CMSCollections.PATIENTS,
        })) as IListResponsePatients;

        console.log(workersResponse.items);
        console.log(patientsResponse.items);

        setWorkers(workersResponse.items);
        setPatients(patientsResponse.items);
      } catch (e) {}
    };

    doAsync();
  }, []);

  function addInfoWindow(marker: any, message: any) {
    const infoWindow = new win.google.maps.InfoWindow({
      content: message,
    });

    win.google.maps.event.addListener(marker, 'click', function () {
      infoWindow.open(map, marker);
    });
  }

  useEffect(() => {
    if (!map || !workers || !patients) return;

    const bounds = new win.google.maps.LatLngBounds();

    const patientRedImage =
      'https://developers.google.com/maps/documentation/javascript/examples/full/images/beachflag.png';
    const patientGreenImage =
      'https://developers.google.com/maps/documentation/javascript/examples/full/images/beachflag.png';
    const patientYellowImage =
      'https://developers.google.com/maps/documentation/javascript/examples/full/images/beachflag.png';

    const workerImage =
      'https://developers.google.com/maps/documentation/javascript/examples/full/images/beachflag.png';

    const usersToInspect: IUserWithMarkerData[] = []; // patients.merge(workers);

    patients.forEach((patient) => {
      const userPatient = getSourceEntityData({ obj: patient, key: nameof<IPatient>('userId') });
      if (!userPatient.dirtyAddress || !userPatient.dirtyAddress?.lat || !userPatient.dirtyAddress?.lng) {
        usersToInspect.push({ ...patient, iconColor: '#EA5455', stateColor: '' });
      }

      const closeWorkersFromPatient = workers.filter((worker) => {
        const userWorker = getSourceEntityData({ obj: worker, key: nameof<IWorker>('userId') });
        if (!userWorker.dirtyAddress || !userWorker.dirtyAddress?.lat || !userWorker.dirtyAddress?.lng) {
          return;
        }

        const ditanceFromWorker = getDistanceFromLatLonInKm(
          userPatient.dirtyAddress?.lng,
          userPatient.dirtyAddress?.lat,
          userWorker.dirtyAddress?.lng,
          userWorker.dirtyAddress?.lat
        );

        const TOLERANCE_WORKER_DISTANCE_FROM_PATIENT_IN_KM = 5;

        return ditanceFromWorker <= TOLERANCE_WORKER_DISTANCE_FROM_PATIENT_IN_KM;
      });

      const MINIMUM_QUANTITY_OF_WORKERS = 5;
      const TOLERANCE_WORKER_QUANTITY_FOR_PATIENTS = 10;

      if (closeWorkersFromPatient.length >= TOLERANCE_WORKER_QUANTITY_FOR_PATIENTS) {
        usersToInspect.push({
          ...patient,
          iconColor: '#28C76F',
          stateColor: '#28C76F',
          nearWorkers: closeWorkersFromPatient.length,
        });
      } else if (
        closeWorkersFromPatient.length >= MINIMUM_QUANTITY_OF_WORKERS &&
        closeWorkersFromPatient.length < TOLERANCE_WORKER_QUANTITY_FOR_PATIENTS
      ) {
        usersToInspect.push({
          ...patient,
          iconColor: '#FF9F43',
          stateColor: '#FF9F43',
          nearWorkers: closeWorkersFromPatient.length,
        });
      } else {
        usersToInspect.push({
          ...patient,
          iconColor: '#EA5455',
          stateColor: '#EA5455',
          nearWorkers: closeWorkersFromPatient.length,
        });
      }
    });

    workers.forEach((worker) => {
      if (worker.workerState && workersInProcessStates.includes(worker.workerState)) {
        usersToInspect.push({
          ...worker,
          iconColor: '#00CFE8',
          workerState: worker.workerState,
          stateColor: '#FF9F43',
        });
      } else {
        usersToInspect.push({
          ...worker,
          iconColor: '#00CFE8',
          workerState: worker.workerState,
          stateColor: '#28C76F',
        });
      }
    });

    usersToInspect.forEach((userWithMarkerData: IUserWithMarkerData) => {
      const marker = new win.google.maps.Marker();
      const relatedUser = getSourceEntityData({ obj: userWithMarkerData, key: 'userId' }) as IUserBasicData;
      if (!relatedUser) return;
      const dirtyAddress = relatedUser.dirtyAddress;
      if (
        !dirtyAddress ||
        !dirtyAddress.addressObject ||
        !dirtyAddress.addressObject.geometry ||
        !dirtyAddress.addressObject.geometry.location
      )
        return;

      const svgMarker = {
        path: 'M-1.547 12l6.563-6.609-1.406-1.406-5.156 5.203-2.063-2.109-1.406 1.406zM0 0q2.906 0 4.945 2.039t2.039 4.945q0 1.453-0.727 3.328t-1.758 3.516-2.039 3.070-1.711 2.273l-0.75 0.797q-0.281-0.328-0.75-0.867t-1.688-2.156-2.133-3.141-1.664-3.445-0.75-3.375q0-2.906 2.039-4.945t4.945-2.039z',
        fillColor: userWithMarkerData.iconColor,
        fillOpacity: 0.8,
        strokeWeight: 0,
        rotation: 0,
        scale: 2,
        anchor: new win.google.maps.Point(0, 20),
      };

      let showInfo = `<div>
          <h3 style="font-size: 10; color: black !important;">
          ${capitalize(userWithMarkerData.firstName) + ' ' + capitalize(userWithMarkerData.lastName)}
          </h3>`;
      if (userWithMarkerData.workerState) {
        showInfo += `
          <div class="box-container" key="idx" style="display: flex; align-items: center;">
            <svg class="svg-icon" style="color: ${userWithMarkerData.stateColor}; height: 15px; width: 15px">
              <circle cx="0.375rem" cy="0.375rem" r="0.375rem" fill="currentColor" />
            </svg>
            <span class="typography-text" style="color:black">
              ${capitalize(t(userWithMarkerData.workerState))}
            </span>
          </div>
        </div>`;
      } else {
        showInfo += `
        <div class="box-container" key="idx" style="display: flex; align-items: center;">
        <svg class="svg-icon" style="color: ${userWithMarkerData.stateColor}; height: 15px; width: 15px">
          <circle cx="0.375rem" cy="0.375rem" r="0.375rem" fill="currentColor" />
        </svg>
        <span class="typography-text" style="color:black">
          ${userWithMarkerData.nearWorkers} ${capitalize(t('workers nearby'))}
        </span>
      </div>
        </div>`;
      }

      marker.setOptions({
        position: dirtyAddress.addressObject.geometry.location,
        draggable: false,
        map: map,
        icon: svgMarker,
      });

      addInfoWindow(marker, showInfo);
    });

    let max_latitude = -400,
      min_latitude = 400,
      max_longitude = -400,
      min_logitude = 400;

    usersToInspect.forEach((userWithMarkerData) => {
      const relatedUser = getSourceEntityData({ obj: userWithMarkerData, key: 'userId' }) as IUserBasicData;
      if (!relatedUser.dirtyAddress || !relatedUser.dirtyAddress?.lat || !relatedUser.dirtyAddress?.lng) {
        return;
      }
      if (max_latitude < relatedUser.dirtyAddress.lat) max_latitude = relatedUser.dirtyAddress.lat;
      if (min_latitude > relatedUser.dirtyAddress.lat) min_latitude = relatedUser.dirtyAddress.lat;
      if (max_longitude < relatedUser.dirtyAddress.lng) max_longitude = relatedUser.dirtyAddress.lng;
      if (min_logitude > relatedUser.dirtyAddress.lng) min_logitude = relatedUser.dirtyAddress.lng;
    });

    const latitude = (max_latitude + min_latitude) / 2;
    const longitude = (max_longitude + min_logitude) / 2;
    // const latitude = Math.abs((max_latitude - (max_latitude + min_latitude) / 2) * 3);
    // const longitude = Math.abs((max_longitude - (max_longitude + min_logitude) / 2) * 3);

    bounds.extend({
      lat: latitude,
      lng: longitude,
    });

    map.fitBounds(bounds);

    // map.setOptions({ maxZoom: 17 });

    // const listener = win.google.maps.event.addListener(map, 'idle', function () {
    map.setZoom(4);
    //   win.google.maps.event.removeListener(listener);
    // });
  }, [map, patients, workers]);

  useEffect(() => {
    if (!win.google) return;

    const mapAux = new win.google.maps.Map(document.getElementById('map-canvas'), {
      center: {
        lat: -33.40338,
        lng: -65.17403,
      },
      zoom: 4,
    });

    // if (!marker) setMarker(new win.google.maps.Marker());

    // if (!circle) setCircle(new win.google.maps.Circle());

    setMap(mapAux);
  }, [win.google]);

  // const setZoomMaps = () => {
  //   if (radioDistance == 50) return 9;
  //   else if (radioDistance == 20) return 10;
  //   else if (radioDistance == 10) return 11;
  //   else if (radioDistance == 5) return 12;

  //   return 9;
  // };

  if (loading) return <Loader />;

  return (
    <Card>
      <CardHeader title={title ?? ''} />
      <CardContent>
        <Grid container spacing={0}>
          <Grid item xs={12}>
            <Card>
              {/* <Divider sx={{ m: '0 !important' }} /> */}
              <div id='map-canvas' style={{ height: 390 }} />
            </Card>
          </Grid>
        </Grid>
      </CardContent>
    </Card>
  );
};

export default RecruitmentMap;
