// formik components

import Button from '@mui/material/Button';
import Card from '@mui/material/Card';
import CardHeader from '@mui/material/CardHeader';
import { useCallback, useEffect, useState } from 'react';
import Icon from 'src/@core/components/icon';
import Loader from 'src/@core/components/loader';
import {
  getSourceEntityData,
  handleError,
  nameof,
  parseDateToDateTimeString,
  splitByUppercase,
  hasRole,
} from 'src/@core/coreHelper';
import { IEntitySchema, IEntitySchemaField, IEntitySchemaWithFields, ISelectOptionEntity } from 'src/types/entities';

import { DataGrid, GridColDef } from '@mui/x-data-grid';

import Box from '@mui/material/Box';
import Typography from '@mui/material/Typography';
import CustomChip from 'src/@core/components/mui/chip';

import { useRouter } from 'next/router';

import { CardContent, Divider, Grid, IconButton, MenuItem, Tooltip, capitalize } from '@mui/material';
import { ThemeColor } from 'src/@core/layouts/types';

import Fuse from 'fuse.js';
import { useTranslation } from 'react-i18next';
import CustomAvatar from 'src/@core/components/mui/avatar';
import CustomTextField from 'src/@core/components/mui/text-field';
import { getInitials } from 'src/@core/utils/get-initials';
import { useDynamics } from 'src/hooks/useDynamics';
import { dynamicGet } from 'src/services/entitiesDynamicServices';
import { IForm } from 'src/types/dynamics';
import { IWorker, WorkerStateTypes, IUsersAddress, IUserBasicData } from 'src/types/@autogenerated';
import { CMSCollections } from 'src/types/@autogenerated';
import { useCurrentUser } from 'src/hooks/useCurrentUser';
import { UserDefinedRols } from 'src/types/userDefinedRols';
import { AppRols } from 'src/types/appRols';
import { formatDate } from 'src/@core/utils/format';
import { createEntityDataBySchema, schemaToForm } from 'src/views/components/dynamics/helpers';
import DynamicFormSidebar from 'src/views/components/dynamics/DynamicFormSidebar';
import debounce from 'debounce-promise';

const ITEM_HEIGHT = 48;
const ITEM_PADDING_TOP = 8;

const MenuProps = {
  PaperProps: {
    style: {
      width: 250,
      maxHeight: ITEM_HEIGHT * 4.5 + ITEM_PADDING_TOP,
    },
  },
};

const SCHEMA_NAME = CMSCollections.WORKERS;

interface IWorkerRow extends IWorker {
  showRow?: boolean;
  workerAddress: string | null;
}

interface CellType {
  row: IWorkerRow;
}
const inProcessCodes = [
  'pending-availability',
  'pending-docs',
  'pending-preferences',
  'pending-experience',
  'pending-general-info',
  'pending-interview',
];

const inProcessStates = [
  WorkerStateTypes.PENDING_AVAILABILITY,
  WorkerStateTypes.PENDING_DOCS,
  WorkerStateTypes.PENDING_EXPERIENCE,
  WorkerStateTypes.PENDING_GENERAL_INFO,
  WorkerStateTypes.PENDING_INTERVIEW,
  WorkerStateTypes.PENDING_PREFERENCES,
];

const CompaniesList = ({}) => {
  // ** Hooks
  const router = useRouter();
  const dynamics = useDynamics();
  const { t } = useTranslation();
  const currentUser = useCurrentUser();
  const queryAction = router.query['action'] as string;

  // ** State
  const [entitySchema, setEntitySchema] = useState<IEntitySchema | null>(null);
  const [entitySchemaFields, setEntitySchemaFields] = useState<IEntitySchemaField[]>([]);

  const [entitiesData, setEntitiesData] = useState<IWorkerRow[]>([]);
  const [count, setCount] = useState<number>();

  const [loadingSchema, setLoadingSchema] = useState<boolean>(true);
  const [loadingData, setLoadingData] = useState<boolean>(false);

  const [isFirstLoad, setIsFirstLoad] = useState<boolean>(true);

  const [paginationModel, setPaginationModel] = useState({ page: 0, pageSize: 10 });
  const [triggerPagination, setTriggerPagination] = useState({ page: 0, pageSize: 10 });

  const [columns, setColumns] = useState<GridColDef[]>([]);

  const [searchText, setSearchText] = useState<string>('');

  const [workerStateTypeOptions, setWorkerStateTypeOptions] = useState<any[]>([]);

  const [selectedWorkerStateTypeOptions, setSelectedWorkerStateTypeOptions] = useState<string[] | any[]>([
    WorkerStateTypes.ACTIVE,
    WorkerStateTypes.INFORMATION_COMPLETED,
    'in-process',
  ]);

  const [addNewEntityForm, setAddNewEntityForm] = useState<IForm | undefined>();

  const [toggleData, setToggleData] = useState<boolean>(false);

  const [addSidebarOpen, setAddSidebarOpen] = useState<boolean>(queryAction === 'create' ? true : false);

  const toggleAddDrawer = () => setAddSidebarOpen(!addSidebarOpen);

  const onPaginationModelChange = (value: any) => {
    setPaginationModel(value);
    setTriggerPagination(value);
  };

  const isPermittedByRol = () => {
    return (
      !currentUser.isLoading &&
      !!currentUser.currentUser &&
      (hasRole(currentUser.currentUser?.appRols, AppRols.APP_ADMIN) ||
        hasRole(currentUser.currentUser?.userDefinedRols, UserDefinedRols.UDR_STAFF_RECRUITER))
    );
  };

  // ** Effects
  useEffect(() => {
    const doAsync = async () => {
      try {
        setLoadingSchema(true);
        if (dynamics.isLoadingSchemas || !dynamics.entitySchemas || !dynamics.entitySchemasFields) return null;

        const schema = dynamics.entitySchemas.find((schema) => {
          return schema.name === SCHEMA_NAME;
        });
        if (!schema) throw new Error('Missing schemaName: ' + SCHEMA_NAME);

        const schemaFields = dynamics.entitySchemasFields.filter((field) => {
          return field.schemaId === schema.id;
        });

        // Fetch Schema
        // const entitySchemaResponse = (await getEntitySchemaByName(schemaName)) as IEntitySchemaWithFields;
        const entitySchemaResponse: IEntitySchemaWithFields = { ...schema, fields: schemaFields };

        setEntitySchema(entitySchemaResponse);
        setEntitySchemaFields(
          entitySchemaResponse.fields.sort((a, b) => {
            return a.order - b.order;
          })
        );

        setLoadingSchema(false);
      } catch (e: any) {
        handleError(e);
        setLoadingSchema(false);
      }
    };

    doAsync();

    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [dynamics.isLoadingSchemas]);

  // define columns and filters
  useEffect(() => {
    const doAsync = async () => {
      try {
        if (!entitySchema || !entitySchemaFields) return;

        // Define table columns
        updateColumnsData();

        // define filters options
        const field = entitySchemaFields.find((field) => {
          return field.name === 'workerState';
        });

        if (field && field.relationshipSchemaId && dynamics.entitySchemas) {
          const relatedSchema = dynamics.entitySchemas.find((schema) => {
            return schema.id === field.relationshipSchemaId;
          });

          if (relatedSchema) {
            const optionsData: any = await dynamicGet({ params: '/cms/' + relatedSchema.name });
            const renderOptions = optionsData.items.filter(
              (option: ISelectOptionEntity) => !inProcessCodes.includes(option.code)
            );
            renderOptions.push({ code: 'in-process', name: 'in process' });
            setWorkerStateTypeOptions(renderOptions as any[]);
          }
        }
      } catch (e: any) {
        handleError(e);
      }
    };

    doAsync();
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [entitySchema, entitySchemaFields]);

  const searchWorkersDebounced = async (
    entitySchema: any,
    workerStateTypeOptionsFilter: string[],
    offset: number,
    limit: number,
    searchText: string
  ) => {
    return dynamicGet({
      params: '/cms/' + entitySchema?.name,
      filters: [
        {
          key: 'workerState',
          value: workerStateTypeOptionsFilter,
          operator: '$in',
        },
        { key: 'lastName', value: searchText, operator: '$contains' },
      ],
      indexedFilters: ['lastName'],
      limit,
      offset,
    });
  };

  // eslint-disable-next-line react-hooks/exhaustive-deps
  const searchDebounce = useCallback(debounce(searchWorkersDebounced, 1000), []);

  useEffect(() => {
    if (!entitySchema || !entitySchemaFields) return;

    setPaginationModel({ page: 0, pageSize: paginationModel.pageSize });
  }, [searchText]);

  // Fetch schema.collectionName
  useEffect(() => {
    const doAsync = async () => {
      try {
        if (!entitySchema || !entitySchemaFields) return;

        // Define table columns
        updateColumnsData();

        setLoadingData(true);
        let workerStateTypeOptionsFilter: string[] = selectedWorkerStateTypeOptions.filter(
          (option) => option !== 'in-process'
        );
        // load entity data
        if (selectedWorkerStateTypeOptions.includes('in-process')) {
          workerStateTypeOptionsFilter = workerStateTypeOptionsFilter.concat(inProcessCodes);
        }

        const offset = paginationModel.pageSize * paginationModel.page;

        const workersResponse: any = await dynamicGet({
          params: '/cms/' + entitySchema.name,
          filters: [
            {
              key: 'workerState',
              value: workerStateTypeOptionsFilter,
              operator: '$in',
            },
            { key: 'lastName', value: searchText, operator: '$contains' },
          ],
          limit: paginationModel.pageSize,
          offset,
        });

        setEntitiesData(
          workersResponse.items.map((worker: IWorker) => {
            const relatedWoerkeUser = getSourceEntityData({
              obj: worker,
              key: nameof<IWorker>('userId'),
            }) as IUserBasicData;

            let addressCity = '';
            if (relatedWoerkeUser && relatedWoerkeUser.dirtyAddress && relatedWoerkeUser.dirtyAddress.city) {
              addressCity = relatedWoerkeUser.dirtyAddress.city;
            }

            return {
              ...worker,
              showRow: true,
              workerAddress: addressCity,
            } as IWorkerRow;
          }) as IWorkerRow[]
        );

        if (workersResponse.total) setCount(workersResponse.total);
        setLoadingData(false);
      } catch (e: any) {
        setLoadingData(false);
        handleError(e);
      }
    };

    doAsync();
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [entitySchema, entitySchemaFields, selectedWorkerStateTypeOptions, triggerPagination]);

  useEffect(() => {
    const doAsync = async () => {
      try {
        if (!entitySchema || !entitySchemaFields) return;

        setLoadingData(true);
        let workerStateTypeOptionsFilter: string[] = selectedWorkerStateTypeOptions.filter(
          (option) => option !== 'in-process'
        );
        // load entity data
        if (selectedWorkerStateTypeOptions.includes('in-process')) {
          workerStateTypeOptionsFilter = workerStateTypeOptionsFilter.concat(inProcessCodes);
        }

        const workersResponse: any = await searchDebounce(
          entitySchema,
          workerStateTypeOptionsFilter,
          0,
          paginationModel.pageSize,
          searchText
        );

        setEntitiesData(
          workersResponse.items.map((worker: IWorker) => {
            const relatedWoerkeUser = getSourceEntityData({
              obj: worker,
              key: nameof<IWorker>('userId'),
            }) as IUserBasicData;

            let addressCity = '';
            if (relatedWoerkeUser && relatedWoerkeUser.dirtyAddress && relatedWoerkeUser.dirtyAddress.city) {
              addressCity = relatedWoerkeUser.dirtyAddress.city;
            }

            return {
              ...worker,
              showRow: true,
              workerAddress: addressCity,
            } as IWorkerRow;
          }) as IWorkerRow[]
        );

        if (workersResponse.total) setCount(workersResponse.total);
        setLoadingData(false);
      } catch (e: any) {
        setLoadingData(false);
        handleError(e);
      }
    };

    doAsync();
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [searchText]);

  // build and set add form
  useEffect(() => {
    const doAsync = async () => {
      try {
        if (loadingSchema || !entitySchema || !entitySchemaFields) return;

        updateColumnsData();

        let theForm = null;

        const theEntityForm = schemaToForm(entitySchema, entitySchemaFields, null, dynamics, true);

        if (theEntityForm.steps.length && !theEntityForm.steps[0].title) {
          theEntityForm.steps[0].title = capitalize(entitySchema.name);
          theEntityForm.steps[0].iconName = 'tabler:code';
        }

        theEntityForm.steps = [...theEntityForm.steps];
        theForm = theEntityForm;

        setAddNewEntityForm(theForm);
      } catch (e: any) {
        handleError(e);
      }
    };

    doAsync();
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [loadingSchema, entitySchema, entitySchemaFields]);

  const updateColumnsData = () => {
    // TODO - aca podria jugar con una coleccion de 'layouts' donde defina las cols a mostrar
    // TODO - Los layouts podrian definir si se usan tablas o cards, y las cards que prop usar para cada campo en caso de
    // TODO - incluso las cards podrian ser de estructuras template o creadas por el usuario (designer)
    // TODO - Tmb podria jugar con campos virtuales que puedan ser funciones a lo excel o estáticos
    const columnsData: GridColDef[] = [];

    // icons col
    columnsData.push({
      flex: 0.1,
      minWidth: 110,
      field: 'icons',
      headerName: '',

      renderCell: ({ row }: CellType) => (
        <Box sx={{ display: 'flex', alignItems: 'center' }}>
          <Tooltip title='View Content'>
            <IconButton
              size='small'
              sx={{ color: 'text.secondary' }}
              onClick={() => {
                router.push(`/${SCHEMA_NAME}/${row.id}`);
              }}
            >
              <Icon icon='tabler:eye' />
            </IconButton>
          </Tooltip>
        </Box>
      ),
    });

    columnsData.push({
      flex: 0.2,
      minWidth: 110,
      field: 'name',
      headerName: t('name') as string,

      renderCell: ({ row }: CellType) => {
        return (
          <>
            {!!row.avatarUrl && (
              <CustomAvatar src={row.avatarUrl} sx={{ mr: 2.5, width: 38, height: 38, fontWeight: 500 }} />
            )}
            {!row.avatarUrl && (
              <CustomAvatar
                skin='light'
                color={'primary'}
                sx={{
                  mr: 2.5,
                  width: 38,
                  height: 38,
                  fontWeight: 500,
                  fontSize: (theme) => theme.typography.body1.fontSize,
                }}
              >
                {getInitials((row.firstName + ' ' + row.lastName).toUpperCase())}
              </CustomAvatar>
            )}

            <Box sx={{ display: 'flex', alignItems: 'flex-start', flexDirection: 'column' }}>
              <Typography
                noWrap
                // component={Link}
                // href='/apps/user/view/account'
                sx={{
                  fontWeight: 500,
                  textDecoration: 'none',
                  color: 'text.secondary',
                  textTransform: 'capitalize',
                }}
              >
                {row.firstName + ' ' + row.lastName}
              </Typography>
              {row.email && (
                <Typography noWrap variant='body2' sx={{ color: 'text.disabled' }}>
                  {row.email}
                </Typography>
              )}
            </Box>
          </>
        );
      },
    });

    columnsData.push({
      flex: 0.2,
      minWidth: 110,
      field: 'phone',
      headerName: t('phone') as string,

      renderCell: ({ row }: CellType) => {
        return (
          <Box sx={{ display: 'flex', alignItems: 'flex-start', flexDirection: 'column' }}>
            <Typography
              noWrap
              // component={Link}
              // href='/apps/user/view/account'
              sx={{
                fontWeight: 500,
                textDecoration: 'none',
                color: 'text.secondary',
                textTransform: 'capitalize',
              }}
            >
              {row.phoneNumber}
            </Typography>
          </Box>
        );
      },
    });

    columnsData.push({
      flex: 0.2,
      minWidth: 110,
      field: 'location',
      headerName: t('location') as string,

      renderCell: ({ row }: CellType) => {
        return (
          <Box sx={{ display: 'flex', alignItems: 'center' }}>
            <Typography
              noWrap
              // component={Link}
              // href='/apps/user/view/account'
              sx={{
                fontWeight: 500,
                textDecoration: 'none',
                color: 'text.secondary',
                textTransform: 'capitalize',
              }}
            >
              {row.workerAddress ? row.workerAddress : '-'}
            </Typography>
          </Box>
        );
      },
    });

    columnsData.push({
      flex: 0.2,
      minWidth: 110,
      field: 'state',
      headerName: t('state') as string,

      renderCell: ({ row }: CellType) => {
        const workerStatus = getSourceEntityData({ obj: row, key: 'workerState' }).name;

        let statusColor: ThemeColor = 'success';

        if (inProcessCodes.includes(workerStatus)) statusColor = 'warning';
        else if (workerStatus === WorkerStateTypes.INFORMATION_COMPLETED) statusColor = 'info';

        return (
          <Box sx={{ display: 'flex', alignItems: 'center' }}>
            <Box sx={{ display: 'flex', flexDirection: 'column' }}>
              <CustomChip rounded size='small' skin='light' label={capitalize(t(workerStatus))} color={statusColor} />
            </Box>
          </Box>
        );
      },
    });

    columnsData.push({
      flex: 0.2,
      minWidth: 110,
      field: 'updatedAt',
      headerName: t('updated at') as string,

      renderCell: ({ row }: CellType) => {
        return (
          <Box sx={{ display: 'flex', alignItems: 'center' }}>
            <Box sx={{ display: 'flex', flexDirection: 'column' }}>
              <Typography sx={{ fontWeight: 500, color: 'text.secondary' }}>
                {row.updatedAt ? formatDate(row.updatedAt as any) : '-'}
              </Typography>
            </Box>
          </Box>
        );
      },
    });

    setColumns(columnsData);
  };

  const handleOnSubmit = async (formData: any) => {
    try {
      setLoadingData(true);

      if (!entitySchema || !currentUser.currentUser) throw new Error('Missing entitySchema/currentUser.currentUser');

      await createEntityDataBySchema(currentUser.currentUser, entitySchema, entitySchemaFields, formData, null, null);

      // refresco la tabla
      setToggleData(!toggleData);

      // cierro sidebar
      setAddSidebarOpen(false);

      // apago loading
      setLoadingData(false);
    } catch (e) {
      setLoadingData(false);
      handleError(e);
    }
  };
  // const handleSearchFilter = (newText: string) => {};
  const handleWorkerStateTypeOptionsChange = (newValues: string[]) => {
    setSelectedWorkerStateTypeOptions(newValues);
  };

  if (!entitySchema || !entitySchemaFields || loadingSchema) return <Loader />;

  return (
    <>
      <Card>
        <CardHeader sx={{ textTransform: 'capitalize' }} title={t(splitByUppercase(entitySchema.name))} />
        <CardContent>
          <Grid container spacing={6}>
            <Grid item sm={4} xs={12}>
              {workerStateTypeOptions && (
                <CustomTextField
                  select
                  fullWidth
                  label={t('status')}
                  SelectProps={{
                    MenuProps,
                    multiple: true,
                    value: selectedWorkerStateTypeOptions,
                    onChange: (e) => handleWorkerStateTypeOptionsChange(e.target.value as string[]),
                    renderValue: (selected) => (
                      <Box sx={{ display: 'flex', flexWrap: 'wrap' }}>
                        {(selected as unknown as string[] | any[]).map((value) => {
                          const typeOption = workerStateTypeOptions.find((option) => {
                            return option.code === value;
                          });
                          // if (Array.isArray(value))  typeOption = {code: 'in-process', name: 'in process'}
                          if (!typeOption) return '-';

                          return (
                            <CustomChip
                              key={typeOption.code}
                              label={capitalize(t(typeOption.name))}
                              sx={{ m: 0.75 }}
                              skin='light'
                              color='primary'
                            />
                          );
                        })}
                      </Box>
                    ),
                  }}
                >
                  {workerStateTypeOptions.map((selectOption, index) => (
                    <MenuItem key={index} value={selectOption.code}>
                      {capitalize(t(selectOption.name))}
                    </MenuItem>
                  ))}
                </CustomTextField>
              )}
            </Grid>
          </Grid>
        </CardContent>
        <Divider sx={{ m: '0 !important' }} />
        <Box
          sx={{
            py: 4,
            px: 6,
            rowGap: 2,
            columnGap: 4,
            display: 'flex',
            flexWrap: 'wrap',
            alignItems: 'center',

            // justifyContent: 'space-between',
            justifyContent: 'right',
          }}
        >
          {/* <Button color='secondary' variant='tonal' startIcon={<Icon icon='tabler:upload' />}>
        Export
      </Button> */}
          <Box sx={{ rowGap: 2, display: 'flex', flexWrap: 'wrap', alignItems: 'center' }}>
            <CustomTextField
              sx={{ mr: 4 }}
              placeholder={`${capitalize(t('search placeholder'))}`}
              onChange={(e) => setSearchText(e.target.value)}
            />
            {/* {isPermittedByRol() && (
              <Button onClick={toggleAddDrawer} variant='contained' sx={{ '& svg': { mr: 2 } }}>
                <Icon fontSize='1.125rem' icon='tabler:plus' />
                {capitalize(t('new'))}
              </Button>
            )} */}
          </Box>
        </Box>

        <DataGrid
          autoHeight
          rows={entitiesData.filter((item) => {
            return item.showRow;
          })}
          rowHeight={60}
          loading={loadingData}
          columns={columns}
          initialState={{
            columns: {
              columnVisibilityModel: {
                id: false,
              },
            },
          }}
          disableRowSelectionOnClick
          pageSizeOptions={[7, 10, 25, 50]}
          paginationMode={'server'}
          paginationModel={paginationModel}
          onPaginationModelChange={onPaginationModelChange}
          rowCount={count}
        />
        {!!addSidebarOpen && !!addNewEntityForm && !!entitySchema && (
          <DynamicFormSidebar
            isCreating={true}
            onSubmit={handleOnSubmit}
            title={'Crear ' + capitalize(t(splitByUppercase(entitySchema.name)))}
            formId={'crear_' + entitySchema.name}
            preloadForm={addNewEntityForm}
            open={addSidebarOpen}
            toggle={toggleAddDrawer}
            onSubmitDone={() => {
              toggleAddDrawer();

              return Promise.resolve();
            }}
          />
        )}
      </Card>
    </>
  );
};

export default CompaniesList;
