import { Box, Card, CardContent, Divider, Grid, MenuItem } from '@mui/material';
import { useEffect, useState } from 'react';
import { useTranslation } from 'react-i18next';
import Loader from 'src/@core/components/loader';
import CustomTextField from 'src/@core/components/mui/text-field';
import { getDistanceFromLatLonInKm, handleError, hasRole, nameof } from 'src/@core/coreHelper';
import { useCurrentUser } from 'src/hooks/useCurrentUser';
import { useDynamics } from 'src/hooks/useDynamics';
import { dynamicGet } from 'src/services/entitiesDynamicServices';
import {
  CMSCollections,
  IOpenPosition,
  IOpenPositionWorker,
  IUsersAddress,
  IWorker,
  OpenPositionStatusTypes,
  UserDefinedRols,
} from 'src/types/@autogenerated';
import OpenPositionCards from 'src/views/openPositions/cards';

const ALL = 'all';
const APPLIED = 'applied';
const NOT_APPLIED = 'notApplied';

const openPositionFilterValues = [
  { code: ALL, description: 'all' },
  { code: APPLIED, description: 'applied' },
  { code: NOT_APPLIED, description: 'not applied' },
];

interface IOpenPositionResponse extends IOpenPosition {
  applied: boolean;
}
const SCHEMA_NAME = CMSCollections.OPEN_POSITIONS;
const WorkerOpenPositions = () => {
  // ** Hooks
  const dynamics = useDynamics();
  const { t } = useTranslation();
  const currentUser = useCurrentUser();

  // **STATES

  const [entityData, setEntityData] = useState<IWorker>();
  const [isLoading, setIsLoading] = useState<boolean>(false);
  const [entitiesData, setEntitiesData] = useState<IOpenPositionResponse[]>([]);
  const [entitiesDataFilterbyStatus, setEntitiesDataFilterbyStatus] = useState<IOpenPositionResponse[]>([]);
  const [loadingData, setLoadingData] = useState<boolean>(false);
  const [toggleData, setToggleData] = useState<boolean>(false);

  const [filterByStatusValue, setFilterByStatusValue] = useState<string>('all');
  const [primaryAddress, setPrimaryAddress] = useState<IUsersAddress | null>(null);

  useEffect(() => {
    const doAsync = async () => {
      try {
        setIsLoading(true);

        if (currentUser.isLoading) return;

        setIsLoading(false);
      } catch (e: any) {
        setIsLoading(false);
      }
    };

    doAsync();
  }, [currentUser.isLoading]);

  // fetch entity data
  useEffect(() => {
    const doAsync = async () => {
      try {
        if (currentUser.isLoading || loadingData) return;

        setLoadingData(true);
        if (!currentUser.currentUser || !currentUser.currentUser.rolsData || !currentUser.currentUser.rolsData.worker)
          throw new Error('Missing currentUser.currentUser worker data');

        setEntityData(currentUser.currentUser.rolsData.worker);

        const addresses = await dynamicGet({
          params: `/cms/${CMSCollections.USERS_ADDRESSES}/by-user/${currentUser.currentUser.id}`,
        });

        if (addresses && addresses.items && addresses.items.length) {
          let primaryAddress: IUsersAddress = addresses.items.find((address: IUsersAddress) => {
            return address.isPrimary;
          });

          if (!primaryAddress && addresses.items.length) {
            primaryAddress = addresses.items[0] as IUsersAddress;
          }

          if (primaryAddress) {
            setPrimaryAddress(primaryAddress);
          }
        }

        setLoadingData(false);
      } catch (e: any) {
        handleError(e);
        setLoadingData(false);
      }
    };

    doAsync();
  }, [currentUser.isLoading]);

  // gets open positions by worker distance and patient
  useEffect(() => {
    const doAsync = async () => {
      if (!primaryAddress) return;
      try {
        setIsLoading(true);

        const data: any = await dynamicGet({
          params: '/cms/' + CMSCollections.OPEN_POSITIONS,
          filters: [
            {
              key: nameof<IOpenPosition>('statusType'),
              value: OpenPositionStatusTypes.ACTIVE,
              operator: '$in',
            },
          ],
        });
        if (data && data.items) {
          //primero filtra las openpositions segun el rango de kilometros
          const openPositionByAddress = setFilterOpenPositions(data.items);

          //luego vemos si el worker ya se postulo o no, y se le agrega un flag
          const openPositionWithAppliedFlag = await getOpenpositionsAppliedbyWorker(openPositionByAddress);

          //al principio ambas listas tendran los mismo valores
          setEntitiesData(openPositionWithAppliedFlag);
          setEntitiesDataFilterbyStatus(openPositionWithAppliedFlag);
        }

        setIsLoading(false);
      } catch (e: any) {
        setIsLoading(false);
        handleError(e);
      }
    };

    doAsync();
  }, [primaryAddress, toggleData]);

  // filtra la lista de open position por estatus
  useEffect(() => {
    const doAsync = async () => {
      try {
        if (!entitiesData) return;

        if (filterByStatusValue == APPLIED)
          setEntitiesDataFilterbyStatus(entitiesData.filter((openPosition) => openPosition.applied));
        else if (filterByStatusValue == NOT_APPLIED)
          setEntitiesDataFilterbyStatus(entitiesData.filter((openPosition) => !openPosition.applied));
        else setEntitiesDataFilterbyStatus(entitiesData);
      } catch (e: any) {
        handleError(e);
        setIsLoading(false);
      }
    };
    doAsync();
  }, [filterByStatusValue]);

  //devuele la lista de las openposition con el flag si ya el worker applico o no
  const getOpenpositionsAppliedbyWorker = async (openpositionList: IOpenPosition[]) => {
    let openPositionApplied: IOpenPositionWorker[] = [];

    //si no se tiene aun la data del worker
    if (!entityData) return [];

    // verificamos si es un worker
    if (
      !currentUser.isLoading &&
      !!currentUser.currentUser &&
      hasRole(currentUser.currentUser?.userDefinedRols, UserDefinedRols.UDR_WORKERS)
    ) {
      /// obtenemos las Openposition del Worker ya postuladas
      const data: any = await dynamicGet({
        params:
          '/cms/' +
          CMSCollections.OPEN_POSITION_WORKERS +
          '/by-prop/' +
          nameof<IOpenPositionWorker>('userId') +
          '/' +
          entityData.id,
      });
      if (data.items) openPositionApplied = data.items;

      //filtramos y verifcamos para agregar el flag applied
      const filteredData = openpositionList.map((openPosition: IOpenPosition) => {
        let applied = false;

        //devuelve true si estan en OpenPositionWorker
        applied = openPositionApplied.some((e) => e.openPositionId === openPosition.id);

        return { applied, ...openPosition } as IOpenPositionResponse;
      });

      return filteredData;
    }

    //si no es worker, igual se el asigna como false, pero esta no se muestra
    return openpositionList.map((openPosition: IOpenPosition) => {
      return { applied: false, ...openPosition } as IOpenPositionResponse;
    });
  };

  //set el filtro por direccion y rango
  const setFilterOpenPositions = (positions: IOpenPosition[]) => {
    return positions.filter(function (vacant: IOpenPosition) {
      if (!primaryAddress || !primaryAddress.address || !primaryAddress.address.lng || !primaryAddress.address.lat)
        return;

      if (!currentUser.currentUser || !currentUser.currentUser.rolsData || !currentUser.currentUser.rolsData.worker)
        return;

      const ditanceFromWorker = getDistanceFromLatLonInKm(
        vacant.jobAddress?.lng,
        vacant.jobAddress?.lat,
        primaryAddress.address.lng,
        primaryAddress.address.lat
      );

      const TOLERANCE_WORKER_DISTANCE_FROM_PATIENT_IN_KM = currentUser.currentUser.rolsData.worker.maxDistance ?? 5;

      return ditanceFromWorker <= TOLERANCE_WORKER_DISTANCE_FROM_PATIENT_IN_KM && vacant.patient !== undefined;
    });
  };

  const toggle = async () => {
    setToggleData(true);
  };

  if (!currentUser.currentUser) return;

  return (
    <Grid container spacing={6}>
      <Grid item xs={12}>
        <Box
          sx={{
            py: 4,
            rowGap: 2,
            columnGap: 0,
            display: 'flex',
            flexWrap: 'wrap',
            alignItems: 'center',
            justifyContent: 'right',
          }}
        >
          <Card>
            <CardContent>
              <Grid container>
                <Grid item xs={12} md={12}>
                  {t('filter by status')}
                </Grid>
                <Grid item xs={12} md={12}>
                  <CustomTextField
                    select
                    fullWidth
                    defaultValue={filterByStatusValue}
                    onChange={(event) => {
                      setFilterByStatusValue(event.target.value);
                    }}
                  >
                    {openPositionFilterValues.map((item) => {
                      return (
                        <MenuItem key={item.code} value={item.code}>
                          {t(item.description)}
                        </MenuItem>
                      );
                    })}
                  </CustomTextField>
                </Grid>
              </Grid>
            </CardContent>
          </Card>
        </Box>
        {isLoading ? (
          <Loader />
        ) : (
          <OpenPositionCards
            openPositions={entitiesDataFilterbyStatus}
            workerId={currentUser.currentUser.id}
            toggle={toggle}
          />
        )}
      </Grid>
    </Grid>
  );
};

export default WorkerOpenPositions;
