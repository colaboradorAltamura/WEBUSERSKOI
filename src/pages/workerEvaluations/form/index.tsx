import {
  Accordion,
  AccordionDetails,
  AccordionSummary,
  Box,
  Button,
  Divider,
  Grid,
  MenuItem,
  Typography,
  useTheme,
} from '@mui/material';
import { Form, Formik } from 'formik';
import { useTranslation } from 'react-i18next';
import { DynamicComponentTypes, IForm } from 'src/types/dynamics';
import { forwardRef, SyntheticEvent, useEffect, useState } from 'react';
import * as Yup from 'yup';
import moment from 'moment';
import { dynamicCreate, dynamicGet } from 'src/services/entitiesDynamicServices';
import {
  CMSCollections,
  IWorkerEvaluation,
  UserDefinedRols,
  IQuestionsType,
  IWorkerEvaluationScore,
  WorkerEvaluationStates,
} from 'src/types/@autogenerated';
import { capitalize, getSourceEntityData, handleError, hasRole, nameof } from 'src/@core/coreHelper';
import DialogAction from 'src/@core/components/custom-dialog-action';
import { useCurrentUser } from 'src/hooks/useCurrentUser';
import { Icon } from '@iconify/react';
import { useSettings } from 'src/@core/hooks/useSettings';
import CustomTextField from 'src/@core/components/mui/text-field';
import { AppRols } from 'src/types/appRols';
import Loader from 'src/@core/components/loader';
import DatePicker, { ReactDatePickerProps } from 'react-datepicker';

const STEP_VALIDATIONS = Yup.object().shape({});

interface PropsType {
  docId: string;
  formId?: string;
  preloadForm?: IForm | null;
  open: boolean;
  onClose: () => void;
  onSubmit: (
    workerEvaluationForm: any,
    questionScoreForm: IWorkerEvaluationScore[],
    isCreating: boolean
  ) => Promise<any>;
  onSubmitDone?: (
    workerEvaluationForm: any,
    questionScoreForm: IWorkerEvaluationScore[],
    isCreating: boolean
  ) => Promise<any>;
  initialValues: IWorkerEvaluation;
  isCreating: boolean;
  title?: string;
}

const WorkerEvaluationForm = ({ docId, initialValues, open, onClose, title, onSubmit, isCreating }: PropsType) => {
  // **  HOOKS
  const { t } = useTranslation();
  const { settings } = useSettings();
  const currentUser = useCurrentUser();
  const theme = useTheme();
  const { direction } = theme;

  // ** STATES
  const [workerEvaluationData, setWorkerEvaluationData] = useState<IWorkerEvaluation>(initialValues);
  const [isLoading, setIsLoading] = useState<boolean>(false);
  const [loadingOptions, setLoadingOptions] = useState<boolean>(true);

  // - questions
  const [WorkerNewQuestion, setWorkerNewQuestion] = useState<IQuestionsType[]>([]); //para el nuevo report
  const [WorkerQuestion, setWorkerQuestion] = useState<IWorkerEvaluationScore[]>([]); //para el edit (ya que solo pueden editar las question previamente guardadas)

  // obtenemos los questions del Worker
  useEffect(() => {
    const doAsync = async () => {
      try {
        setLoadingOptions(true);

        //si es una nueva evaluacion
        if (isCreating) {
          const newQuestion = await dynamicGet({
            params: '/cms/' + CMSCollections.QUESTIONS_TYPES,
          });

          if (newQuestion && newQuestion.items) setWorkerNewQuestion(newQuestion.items);
        } else {
          //obtenermos las questions guardardas en la evaluacion
          const questionScoreResponse = await dynamicGet({
            params:
              '/cms/' +
              CMSCollections.WORKER_EVALUATION_SCORES +
              '/by-prop/' +
              nameof<IWorkerEvaluationScore>('workerEvaluationId') +
              '/' +
              initialValues.id,
          });
          if (questionScoreResponse && questionScoreResponse.items) setWorkerQuestion(questionScoreResponse.items);
        }

        setLoadingOptions(false);
      } catch (error) {
        handleError(error);

        setLoadingOptions(false);
      }
    };

    doAsync();
  }, []);

  const closeDialogEdit = () => {
    onClose();
  };

  const submitValues = async (values: any, action: any) => {
    try {
      const itemValues = { ...values };
      if (!currentUser.currentUser) return;

      //validamos que sea clinic el user
      if (
        !hasRole(currentUser.currentUser?.userDefinedRols, UserDefinedRols.UDR_STAFF_CLINIC) &&
        !hasRole(currentUser.currentUser?.appRols, AppRols.APP_ADMIN)
      )
        throw new Error('Missing worker');

      itemValues['evaluationState'] = WorkerEvaluationStates.COMPLETED;
      itemValues['userId'] = docId; //el id del worker //
      itemValues['evaluationDate'] = new Date();
      itemValues['evaluatorId'] = currentUser.currentUser.id;
      itemValues['evaluatorRole'] = currentUser.currentUser.userDefinedRols
        ? currentUser.currentUser.userDefinedRols.toString()
        : '';

      //retorna los questions
      const questionValues = getQuestionsScoreValuesForm() as IWorkerEvaluationScore[];

      //enviamos la data a la vista principal
      onSubmit(itemValues, questionValues, isCreating);
      onClose();
    } catch (error) {
      onClose();
      handleError(error);
    }
  };

  //***** obtiene los datos ingresados en cada input por los obj del worker
  // se valida si es una nueva evaluacion o un edit ya que se usan dos tablas diferentes
  // cuando es una nueva evaluacion, se usan las questions que estan en el questiontype
  // cuando es un edit, se cargan de WorkerEvaluationScore, las cuales ya estan  guardadas
  const getQuestionsScoreValuesForm = () => {
    const workerEvaluationScore = [] as IWorkerEvaluationScore[];

    //si es nuevo, usamos las gol q estan el questiontype, sino, usamos las que ya estan para editar
    if (isCreating) {
      const values = WorkerNewQuestion;

      //por cada question, recorrremos el form
      values.map((question) => {
        if (!question.id) return;

        const inputs = document.getElementsByClassName(question.id);

        if (inputs && inputs.length >= 0) {
          const scoreInput = inputs[0].getElementsByTagName('input');

          if (!scoreInput || !scoreInput[0]) return;

          const score = Number(scoreInput[0].value);

          //asignamos los valores
          const questionScore = {
            workerEvaluationScoreDate: new Date(),
            questionScore: score,
            questionType: question.description,
            questionTypeId: question.id,
            workerId: docId,
            workerEvaluationId: '',
          } as IWorkerEvaluationScore;

          workerEvaluationScore.push(questionScore);
        }
      });
    } else {
      // si es edit, usamos workerQuestionsScore
      const values = WorkerQuestion;

      //por cada question, recorrremos el form
      values.map((question) => {
        if (!question.id) return;

        //la obtneemos por el id IWorkerEvaluationScore
        const inputs = document.getElementsByClassName(question.id);

        if (inputs && inputs.length >= 0) {
          const scoreInput = inputs[0].getElementsByTagName('input');

          if (!scoreInput || !scoreInput[0]) return;

          const score = Number(scoreInput[0].value);

          //asignamos los valores
          const questionScore = {
            id: question.id,
            workerEvaluationScoreDate: new Date(),
            questionScore: score, // el nuevo score
            questionType: question.questionType,
            questionTypeId: question.questionTypeId,
            workerId: docId,
            workerEvaluationId: question.workerEvaluationId,
          } as IWorkerEvaluationScore;
          workerEvaluationScore.push(questionScore);
        }
      });
    }
    // SIEMPREEEEE devuelve un array de IWorkerEvaluationScore
    if (workerEvaluationScore.length) return workerEvaluationScore as IWorkerEvaluationScore[];

    return [];
  };

  //(solo para el edit) obtiene el nombre del question type
  const getQuestionType = (workerScore: IWorkerEvaluationScore) => {
    if (!workerScore) return;

    const sourceData = getSourceEntityData({
      obj: workerScore,
      key: nameof<IWorkerEvaluationScore>('questionTypeId'),
    });

    if (!sourceData) return;

    return sourceData as IQuestionsType;
  };

  //component que muestra el form de los obj
  const WorkerEvaluationQuestionStep = () => {
    return (
      <>
        {loadingOptions ? (
          <Loader />
        ) : (
          <Grid container spacing={0} sx={{ mb: 6 }}>
            <Grid container spacing={5} sx={{ mb: 4 }}>
              <Grid item xs={12} md={3} sm={3}>
                <Typography variant='h5' sx={{ mb: 3 }}>
                  {capitalize(t('name'))}
                </Typography>
              </Grid>
              <Grid item xs={12} md={6} sm={6}>
                <Typography variant='h5' sx={{ mb: 3 }}>
                  {capitalize(t('description'))}
                </Typography>
              </Grid>

              <Grid item xs={12} md={3} sm={3}>
                <Typography variant='h5' sx={{ mb: 3 }}>
                  {capitalize(t('score'))}
                </Typography>
              </Grid>
            </Grid>
            {WorkerQuestion.map((question, index) => {
              return (
                <>
                  <Grid container spacing={5} sx={{ mb: 4 }} key={`container${question.id}`}>
                    <Grid item xs={12} md={3} sm={3} key={`name${question.id}`}>
                      <Typography sx={{ mb: 3 }}>{getQuestionType(question)?.name}</Typography>
                    </Grid>
                    <Grid item xs={12} md={6} sm={6} key={`description${question.id}`}>
                      {getQuestionType(question)?.description}
                    </Grid>
                    <Grid item xs={12} md={3} sm={3} key={`questionScore${question.id}`} className={question.id}>
                      <CustomTextField
                        select
                        fullWidth
                        className='score'
                        defaultValue={question.questionScore ? question.questionScore : 0}
                      >
                        <MenuItem value='0'>0</MenuItem>
                        <MenuItem value='1'>1</MenuItem>
                        <MenuItem value='2'>2</MenuItem>
                        <MenuItem value='3'>3</MenuItem>
                        <MenuItem value='4'>4</MenuItem>
                        <MenuItem value='5'>5</MenuItem>
                      </CustomTextField>
                    </Grid>
                  </Grid>
                </>
              );
            })}

            {WorkerNewQuestion.map((question, index) => {
              return (
                <>
                  <Grid container spacing={5} sx={{ mb: 4 }} key={`container${question.id}`}>
                    <Grid item xs={12} md={3} sm={3} key={`name${question.id}`}>
                      {question.name}
                    </Grid>

                    <Grid item xs={12} md={6} sm={6} key={`questionDescription${question.id}`}>
                      <Typography variant='body2' sx={{ my: 'auto', textAlign: 'center' }}>
                        {question.description}
                      </Typography>
                    </Grid>
                    <Grid item xs={12} md={3} sm={3} key={`questionScore${question.id}`} className={question.id}>
                      <CustomTextField select fullWidth className='score' defaultValue={0}>
                        <MenuItem value='0'>0</MenuItem>
                        <MenuItem value='1'>1</MenuItem>
                        <MenuItem value='2'>2</MenuItem>
                        <MenuItem value='3'>3</MenuItem>
                        <MenuItem value='4'>4</MenuItem>
                        <MenuItem value='5'>5</MenuItem>
                      </CustomTextField>
                    </Grid>
                  </Grid>
                </>
              );
            })}
          </Grid>
        )}
      </>
    );
  };

  return (
    <>
      <DialogAction
        show={open}
        title={capitalize(title ?? t('worker evalutations'))}
        keepMounted
        maxWidth='md'
        colorButtonSubmit='primary'
        showOnClickClose={false}
        onClickClose={() => closeDialogEdit()}
      >
        <Grid>
          <Typography fontSize={11} sx={{ mb: 1, color: 'text.secondary' }}>
            *Puntaje: Nada (0) ; Muy Poco (1) ; Poco (2) ; Médio (3) ; Alto (4) ; Muy Alto (5)
          </Typography>
        </Grid>
        <Divider sx={{ my: '0 !important' }} />
        {open && (
          <Formik
            enableReinitialize={true}
            initialValues={workerEvaluationData}
            validationSchema={STEP_VALIDATIONS}
            onSubmit={submitValues}
          >
            {({ values, errors, touched, isSubmitting, setValues }) => (
              <Form id={'workerEvaluationBasicDataForm'} autoComplete='off'>
                <Grid item xs={12} md={12} lg={12} sx={{ marginTop: '15px' }}>
                  {WorkerEvaluationQuestionStep()}
                  <Grid item xs={12} sx={{ pt: (theme) => `${theme.spacing(6)} !important` }}>
                    <Box sx={{ display: 'flex', justifyContent: 'right' }}>
                      <Button variant='contained' type={'submit'} sx={{ '& svg': { ml: 2 } }}>
                        {capitalize(t('save'))}
                        <Icon fontSize='1.125rem' icon='tabler:check' />
                      </Button>
                    </Box>
                  </Grid>
                </Grid>
              </Form>
            )}
          </Formik>
        )}
      </DialogAction>
    </>
  );
};

export default WorkerEvaluationForm;
