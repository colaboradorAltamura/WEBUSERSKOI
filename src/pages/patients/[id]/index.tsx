// ** Next Import
import { useRouter } from 'next/router';
import { GetStaticPaths, GetStaticProps, GetStaticPropsContext, InferGetStaticPropsType } from 'next/types';
import { SyntheticEvent, useEffect, useState } from 'react';
import { capitalize, handleError, hasRole, nameof, parseDateToDateTimeString } from 'src/@core/coreHelper';
import { useCurrentUser } from 'src/hooks/useCurrentUser';
import { useDynamics } from 'src/hooks/useDynamics';

import { useTheme } from '@mui/material/styles';
import { IEntitySchema, IEntitySchemaField, IEntitySchemaWithFields } from 'src/types/entities';

import TabContext from '@mui/lab/TabContext';
import TabList from '@mui/lab/TabList';
import TabPanel from '@mui/lab/TabPanel';
import Alert from '@mui/material/Alert';
import AlertTitle from '@mui/material/AlertTitle';
import Box from '@mui/material/Box';
import Button from '@mui/material/Button';
import Card from '@mui/material/Card';
import CardContent from '@mui/material/CardContent';
import Divider from '@mui/material/Divider';
import Grid from '@mui/material/Grid';
import IconButton from '@mui/material/IconButton';
import Typography from '@mui/material/Typography';
import { toast } from 'react-hot-toast';
import Icon from 'src/@core/components/icon';
import Loader from 'src/@core/components/loader';
import CustomAvatar from 'src/@core/components/mui/avatar';
import { IForm } from 'src/types/dynamics';
import DynamicFormSidebar from 'src/views/components/dynamics/DynamicFormSidebar';
import {
  getEntityDataBySchema,
  restoreEntityDataBySchema,
  schemaToForm,
  updateEntityDataBySchema,
} from 'src/views/components/dynamics/helpers';

import CardHeader from '@mui/material/CardHeader';
import Tab from '@mui/material/Tab';
import { useTranslation } from 'react-i18next';
import OptionsMenu from 'src/@core/components/option-menu';
import { getInitials } from 'src/@core/utils/get-initials';
import { dynamicGet } from 'src/services/entitiesDynamicServices';
import { CMSCollections, IAddress, IPatient, IUsersAddress } from 'src/types/@autogenerated';
import { AppRols } from 'src/types/appRols';
import { UserDefinedRols } from 'src/types/userDefinedRols';

import AddressTab from 'src/views/patients/AddressTab';
import ContractedServiceTab from 'src/views/patients/ContractedServiceTab';
import DiagnosticTab from 'src/views/patients/DiagnosticTab';
import SearchStatusTab from 'src/views/patients/SearchStatusTab';
import TherapeuticMatchTab from 'src/views/patients/TherapeuticMatchTab';
import ItineraryTab from 'src/views/patients/ItineraryTab';

import TherapeuticProjectTab from 'src/views/patients/TherapeuticProject';
import SummaryTab from '../../../views/patients/SummaryTab';
import DailyReportTab from 'src/views/patients/DailyReportTab';
import SupervisionTab from 'src/views/patients/SupervisionTab';

const SCHEMA_NAME = CMSCollections.PATIENTS;

const PatientEdit = ({}: InferGetStaticPropsType<typeof getStaticProps>) => {
  // ** Hooks
  const router = useRouter();
  const dynamics = useDynamics();
  const currentUser = useCurrentUser();
  const { t } = useTranslation();

  const theme = useTheme();

  // ** Global vars
  const INITIAL_TAB = 'summary';
  const id = router.query.id as string | null;
  const tab = router.query['tab'] as string;

  // ** States
  const [entitySchema, setEntitySchema] = useState<IEntitySchema | null>(null);
  const [entitySchemaFields, setEntitySchemaFields] = useState<IEntitySchemaField[]>([]);
  const [loadingSchema, setLoadingSchema] = useState<boolean>(true);
  const [loadingData, setLoadingData] = useState<boolean>(false);
  const [entityData, setEntityData] = useState<IPatient | null>(null);
  const [toggleData, setToggleData] = useState<boolean>(false);
  const [activeTab, setActiveTab] = useState<string>(tab ? tab : INITIAL_TAB);
  const [editEntityForm, setEditEntityForm] = useState<IForm | null>(null);

  const [editSidebarOpen, setEditSidebarOpen] = useState<boolean>(false);

  // ** Address tab

  const [primaryAddress, setPrimaryAddress] = useState<IAddress | null>(null);
  const [userAddresses, setUserAddresses] = useState<IUsersAddress[]>([]);

  const toggleEditDrawer = () => setEditSidebarOpen(!editSidebarOpen);

  // ** Effects

  // fetch schema
  useEffect(() => {
    const doAsync = async () => {
      try {
        setLoadingSchema(true);

        if (dynamics.isLoadingSchemas || !dynamics.entitySchemas || !dynamics.entitySchemasFields) return null;

        const schema = dynamics.entitySchemas.find((schema) => {
          return schema.name === SCHEMA_NAME;
        });
        if (!schema) throw new Error('Missing schemaName: ' + SCHEMA_NAME);
        const schemaFields = dynamics.entitySchemasFields.filter((field) => {
          return field.schemaId === schema.id;
        });

        // Fetch Schema
        //const entitySchemaResponse = (await getEntitySchemaByName(schemaName)) as IEntitySchemaWithFields;
        const entitySchemaResponse: IEntitySchemaWithFields = { ...schema, fields: schemaFields };

        setEntitySchema(entitySchemaResponse);

        // Fetch Fields
        // const entitySchemaFieldsResponse = await listEntitySchemaFields(entitySchemaResponse.id);

        setEntitySchemaFields(
          entitySchemaResponse.fields.sort((a, b) => {
            return a.order - b.order;
          })
        );

        setLoadingSchema(false);
      } catch (e: any) {
        handleError(e);
        setLoadingSchema(false);
      }
    };

    doAsync();
  }, [dynamics.isLoadingSchemas]);

  // fetch entity data
  useEffect(() => {
    if (!id) return;

    const doAsync = async () => {
      try {
        if (!entitySchema || currentUser.isLoading || loadingData) return;

        setLoadingData(true);

        if (!currentUser.currentUser) throw new Error('Missing currentUser.currentUser');

        const data: IPatient = await getEntityDataBySchema(
          currentUser.currentUser,
          entitySchema,
          entitySchemaFields,
          id,
          null,
          null
        );

        setEntityData(data);

        // carga las direcciones . to do: pasar a un metodo
        if (data) {
          const addresses = await dynamicGet({
            params: `/cms/${CMSCollections.USERS_ADDRESSES}/by-user/${data.id}`,
          });

          if (addresses && addresses.items && addresses.items.length) {
            let primaryAddress: IUsersAddress = addresses.items.find((address: IUsersAddress) => {
              return address.isPrimary;
            });

            if (!primaryAddress && addresses.items.length) {
              primaryAddress = addresses.items[0] as IUsersAddress;
            }

            if (primaryAddress.address && primaryAddress.address) {
              setPrimaryAddress(primaryAddress.address);
            }
            setUserAddresses(addresses.items);
          }
        }

        setLoadingData(false);
      } catch (e: any) {
        handleError(e);
        setLoadingData(false);
      }
    };

    doAsync();
  }, [entitySchema, id, toggleData, currentUser.isLoading]);

  const handleTabChange = (event: SyntheticEvent, value: string) => {
    setLoadingSchema(true);
    setActiveTab(value);

    router
      .push({
        pathname: `/${SCHEMA_NAME}/${id}`,
        query: `tab=${value}`,
      })
      .then(() => setLoadingSchema(false));
  };

  useEffect(() => {
    if (tab && tab !== activeTab) {
      setActiveTab(tab);
    }
  }, [tab]);

  const handleOnEntityEdit = async () => {
    try {
      if (!entitySchema) throw new Error('missing entitySchema');

      // const theForm = getEditEntityForm(entitySchema, entitySchemaFields, dynamics);

      const fieldsNames = [
        nameof<IPatient>('firstName'),
        nameof<IPatient>('lastName'),
        nameof<IPatient>('email'),
        nameof<IPatient>('phoneNumber'),
        nameof<IPatient>('identificationType'),
        nameof<IPatient>('identificationNumber'),
      ];

      const toShowFields = entitySchemaFields.filter((field) => {
        return fieldsNames.includes(field.name);
      });

      const theForm = schemaToForm(entitySchema, toShowFields, null, dynamics);

      setEditEntityForm(theForm);

      setEditSidebarOpen(true);
    } catch (e: any) {
      handleError(e);
    }
  };

  const handleOnEntityRestore = async () => {
    try {
      if (!id) return;

      setLoadingData(true);

      if (!entitySchema || !currentUser.currentUser) throw new Error('Missing entitySchema/currentUser.currentUser');

      await restoreEntityDataBySchema(
        currentUser.currentUser,
        entitySchema,
        entitySchemaFields,
        id,

        null,
        null
      );

      // refresco la info
      setToggleData(!toggleData);

      toast.success('successfull restored');

      // cierro sidebar
      setEditSidebarOpen(false);

      // apago loading
      setLoadingData(false);
    } catch (e) {
      setLoadingData(false);
      handleError(e);
    }
  };

  const handleOnEditSubmit = async (formData: any) => {
    try {
      if (!id) return;

      setLoadingData(true);

      if (!entitySchema || !currentUser.currentUser) throw new Error('Missing entitySchema/currentUser.currentUser');

      await updateEntityDataBySchema(
        currentUser.currentUser,
        entitySchema,
        entitySchemaFields,
        id,
        formData,
        null,
        null
      );

      // refresco la tabla
      setToggleData(!toggleData);

      // cierro sidebar
      setEditSidebarOpen(false);

      // apago loading
      setLoadingData(false);
    } catch (e) {
      setLoadingData(false);
      handleError(e);
    }
  };

  const handleOnTabUpdateData = async () => {
    try {
      // refresco la tabla
      setToggleData(!toggleData);
    } catch (e) {
      handleError(e);
    }
  };

  const isPermittedByRol = () => {
    return (
      !currentUser.isLoading &&
      !!currentUser.currentUser &&
      (hasRole(currentUser.currentUser?.appRols, AppRols.APP_ADMIN) ||
        hasRole(currentUser.currentUser?.userDefinedRols, UserDefinedRols.UDR_STAFF_ADMISSION))
    );
  };

  const renderLeftPanel = () => {
    if (!entitySchema || !entityData) return;

    return (
      <Grid container spacing={6}>
        <Grid item xs={12}>
          <Card>
            {entityData.state !== 0 && (
              <CardHeader
                action={
                  isPermittedByRol() && (
                    <OptionsMenu
                      options={[
                        {
                          text: capitalize(t('edit')),
                          menuItemProps: {
                            sx: { py: 2 },
                            onClick: () => {
                              handleOnEntityEdit();
                            },
                          },
                        },
                      ]}
                      iconButtonProps={{ size: 'small', sx: { color: 'text.disabled' } }}
                    />
                  )
                }
              />
            )}
            <CardContent sx={{ pt: 13.5, display: 'flex', alignItems: 'center', flexDirection: 'column' }}>
              <CustomAvatar
                skin='light'
                variant='rounded'
                color={'primary'}
                sx={{ width: 100, height: 100, mb: 4, fontSize: '3rem' }}
              >
                {getInitials(entityData.firstName + ' ' + entityData.lastName).toUpperCase()}
              </CustomAvatar>

              <Typography variant='h4' sx={{ mb: 3, textTransform: 'capitalize' }}>
                {entityData.firstName + ' ' + entityData.lastName}
              </Typography>
            </CardContent>

            <Divider sx={{ my: '0 !important', mx: 6 }} />

            <CardContent sx={{ pb: 2 }}>
              <Box sx={{ pt: 2 }}>
                <Box sx={{ display: 'flex', mb: 3, margin: 2 }}>
                  <Grid sx={{ ml: 2 }}>
                    <Icon fontSize='1.2rem' icon={'tabler:mail'} />
                  </Grid>
                  <Grid sx={{ ml: 2 }}>
                    <Typography sx={{ color: 'text.secondary' }}>{entityData.email}</Typography>
                  </Grid>
                </Box>
                <Box sx={{ display: 'flex', mb: 3, margin: 2 }}>
                  <Grid sx={{ ml: 2 }}>
                    <Icon fontSize='1.2rem' icon={'tabler:phone'} />
                  </Grid>
                  <Grid sx={{ ml: 2 }}>
                    <Typography sx={{ color: 'text.secondary' }}>{entityData.phoneNumber}</Typography>
                  </Grid>
                </Box>
                <Box sx={{ display: 'flex', mb: 3, margin: 2 }}>
                  <Grid sx={{ ml: 2, maxHeight: 20 }}>
                    <Icon fontSize='1.2rem' icon={'tabler:home'}></Icon>
                  </Grid>
                  <Grid sx={{ ml: 2 }}>
                    <Typography sx={{ color: 'text.secondary' }}>{primaryAddress?.addressString}</Typography>
                  </Grid>
                </Box>
                <Box sx={{ display: 'flex', mb: 3, margin: 2 }}>
                  <Grid sx={{ ml: 2 }}>
                    <Icon color={theme.palette.primary.main} fontSize='1.2rem' icon={'tabler:clock-edit'} />
                  </Grid>
                  <Grid sx={{ ml: 2 }}>
                    <Typography sx={{ color: 'text.secondary' }}>
                      {parseDateToDateTimeString(entityData.updatedAt)}
                    </Typography>
                  </Grid>
                </Box>
              </Box>
            </CardContent>
          </Card>
        </Grid>
      </Grid>
    );
  };

  const renderRightPanel = () => {
    // si el value de actuve Tab se imprime antes de los tabs estalla el comp
    if (!activeTab || !entitySchema || !id || !entityData) return null;

    return (
      <TabContext value={activeTab}>
        <TabList variant='scrollable' scrollButtons='auto' onChange={handleTabChange} aria-label='forced scroll tabs'>
          <Tab value={INITIAL_TAB} label={t('summary')} sx={{ textTransform: 'capitalize' }} />
          <Tab value={'address'} label={t('address')} sx={{ textTransform: 'capitalize' }} />
          <Tab value={'contracted-service'} label={t('contracted service')} sx={{ textTransform: 'capitalize' }} />
          <Tab value={'diagnostic'} label={t('diagnostic')} sx={{ textTransform: 'capitalize' }} />
          <Tab value={'therapeutic-project'} label={t('therapeutic project')} sx={{ textTransform: 'capitalize' }} />
          <Tab value={'search-status'} label={t('searchStatus')} sx={{ textTransform: 'capitalize' }} />
          <Tab value={'itinerary'} label={t('itinerary')} sx={{ textTransform: 'capitalize' }} />
          <Tab value={'therapeutic-match'} label={t('therapeutic-match')} sx={{ textTransform: 'capitalize' }} />
          <Tab value={'daily-report'} label={t('daily report')} sx={{ textTransform: 'capitalize' }} />
          <Tab value={'supervision'} label={t('supervision')} sx={{ textTransform: 'capitalize' }} />
        </TabList>

        <TabPanel sx={{ p: 0 }} value={INITIAL_TAB}>
          <SummaryTab
            docId={id}
            schemaArg={entitySchema}
            schemaFieldsArg={entitySchemaFields}
            dataArg={entityData}
            onUpdatePatient={handleOnTabUpdateData}
            primaryAddressArg={primaryAddress}
          />
        </TabPanel>
        <TabPanel sx={{ p: 0 }} value={'address'}>
          <AddressTab
            docId={id}
            patientSchemaArg={entitySchema}
            patientSchemaFieldsArg={entitySchemaFields}
            patientDataArg={entityData}
            onUpdatePatient={handleOnTabUpdateData}
            primaryAddressArg={primaryAddress}
            addresses={userAddresses ?? null}
          />
        </TabPanel>
        <TabPanel sx={{ p: 0 }} value={'search-status'}>
          <SearchStatusTab docId={id} patient={entityData} addresses={userAddresses} />
        </TabPanel>
        <TabPanel sx={{ p: 0 }} value={'therapeutic-match'}>
          <TherapeuticMatchTab docId={id} patient={entityData} addresses={userAddresses} />
        </TabPanel>

        <TabPanel sx={{ p: 0 }} value={'itinerary'}>
          <ItineraryTab docId={id} patient={entityData} addresses={userAddresses} />
        </TabPanel>

        <TabPanel sx={{ p: 0 }} value={'contracted-service'}>
          <ContractedServiceTab
            docId={id}
            patientSchemaArg={entitySchema}
            patientSchemaFieldsArg={entitySchemaFields}
            patientDataArg={entityData}
            primaryAddressArg={primaryAddress}
            onUpdatePatient={handleOnTabUpdateData}
          />
        </TabPanel>
        <TabPanel sx={{ p: 0 }} value={'diagnostic'}>
          <DiagnosticTab
            docId={id}
            patientSchemaArg={entitySchema}
            patientSchemaFieldsArg={entitySchemaFields}
            patientDataArg={entityData}
            onUpdatePatient={handleOnTabUpdateData}
          />
        </TabPanel>
        <TabPanel sx={{ p: 0 }} value={'therapeutic-project'}>
          <TherapeuticProjectTab
            docId={id}
            patientSchemaArg={entitySchema}
            patientSchemaFieldsArg={entitySchemaFields}
            patientDataArg={entityData}
            onUpdatePatient={handleOnTabUpdateData}
          />
        </TabPanel>
        <TabPanel sx={{ p: 0 }} value={'daily-report'}>
          <DailyReportTab
            docId={id}
            patientSchemaArg={entitySchema}
            patientSchemaFieldsArg={entitySchemaFields}
            patientDataArg={entityData}
            onUpdatePatient={handleOnTabUpdateData}
          />
        </TabPanel>
        <TabPanel sx={{ p: 0 }} value={'supervision'}>
          <SupervisionTab
            docId={id}
            schemaArg={entitySchema}
            schemaFieldsArg={entitySchemaFields}
            dataArg={entityData}
            onUpdatePatient={handleOnTabUpdateData}
          />
        </TabPanel>
      </TabContext>
    );
  };

  if (router.isFallback) {
    return <h1>Loading...</h1>;
  }

  if (!id) {
    toast.error('Missing id');
    console.error('Missing args', router);
    // router.push('/500');

    return <h1>Loading...</h1>;
  }

  if (!dynamics.entitySchemas || !dynamics.entitySchemasFields) return <Loader />;

  if (loadingSchema || loadingData) return <Loader />;

  if (!entityData) return <>Error loading data</>;

  return (
    <Grid container spacing={6}>
      <Grid item xs={12} md={12} lg={12}>
        <Card>
          {/* <CardContent sx={{ pt: 0, display: 'flex', alignItems: 'left', flexDirection: 'column' }}>back</CardContent> */}
          <IconButton
            color='inherit'
            onClick={() => {
              // TODO Hacer HistoryContext
              const splittedUrl = router.asPath.split('/');

              const backRoute = splittedUrl.reduce((prev, curr, index) => {
                if (index === splittedUrl.length - 2) return prev;

                return prev + '/' + curr;
              });

              router.push(backRoute);
            }}
          >
            <Icon fontSize='1.625rem' icon='tabler:arrow-badge-left-filled' />
          </IconButton>
          {entityData.state === 0 && (
            <Alert
              severity='warning'
              action={
                <Button
                  color='inherit'
                  size='small'
                  onClick={() => {
                    handleOnEntityRestore();
                  }}
                >
                  Undo
                </Button>
              }
            >
              <AlertTitle>This entity is deleted!</AlertTitle>
            </Alert>
          )}
        </Card>
      </Grid>

      <Grid item xs={12} md={5} lg={4}>
        {renderLeftPanel()}
      </Grid>
      <Grid item xs={12} md={7} lg={8}>
        {renderRightPanel()}
      </Grid>

      {!!editSidebarOpen && (
        <DynamicFormSidebar
          isCreating={false}
          onSubmit={handleOnEditSubmit}
          title={'Edit ' + entitySchema?.name}
          formId={'Edit_' + entitySchema?.name}
          initialValues={entityData}
          preloadForm={editEntityForm}
          open={editSidebarOpen}
          toggle={toggleEditDrawer}
          onSubmitDone={() => {
            toggleEditDrawer();

            return Promise.resolve();
          }}
        />
      )}
    </Grid>
  );
};

export const getStaticPaths: GetStaticPaths = () => {
  return {
    paths: [],
    fallback: true,
  };
};

export const getStaticProps: GetStaticProps = async ({ params }: GetStaticPropsContext) => {
  return {
    props: {
      id: params?.id,
      // tab: params?.tab,
    },
  };
};

export default PatientEdit;
