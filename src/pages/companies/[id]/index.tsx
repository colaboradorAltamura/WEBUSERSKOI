// ** Next Import
import { useRouter } from 'next/router';
import { GetStaticPaths, GetStaticProps, GetStaticPropsContext, InferGetStaticPropsType } from 'next/types';
import { SyntheticEvent, useEffect, useState } from 'react';
import {
  capitalize,
  getSourceEntityData,
  handleError,
  hasRole,
  nameof,
  parseDateToDateTimeString,
} from 'src/@core/coreHelper';
import { useCurrentUser } from 'src/hooks/useCurrentUser';
import { useDynamics } from 'src/hooks/useDynamics';

import { CMSCollections, ICompany } from 'src/types/@autogenerated';
import { IEntitySchema, IEntitySchemaField, IEntitySchemaWithFields } from 'src/types/entities';
import { useTheme } from '@mui/material/styles';

import TabContext from '@mui/lab/TabContext';
import TabList from '@mui/lab/TabList';
import TabPanel from '@mui/lab/TabPanel';
import Alert from '@mui/material/Alert';
import AlertTitle from '@mui/material/AlertTitle';
import Box from '@mui/material/Box';
import Button from '@mui/material/Button';
import Card from '@mui/material/Card';
import CardContent from '@mui/material/CardContent';
import Divider from '@mui/material/Divider';
import Grid from '@mui/material/Grid';
import IconButton from '@mui/material/IconButton';
import Typography from '@mui/material/Typography';
import { toast } from 'react-hot-toast';
import Icon from 'src/@core/components/icon';
import Loader from 'src/@core/components/loader';
import CustomAvatar from 'src/@core/components/mui/avatar';
import { IForm } from 'src/types/dynamics';
import DynamicFormSidebar from 'src/views/components/dynamics/DynamicFormSidebar';
import {
  getEntityDataBySchema,
  removeEntityDataBySchema,
  restoreEntityDataBySchema,
  schemaToForm,
  updateEntityDataBySchema,
} from 'src/views/components/dynamics/helpers';

import CardActions from '@mui/material/CardActions';
import Tab from '@mui/material/Tab';
import { useTranslation } from 'react-i18next';
import { getInitials } from 'src/@core/utils/get-initials';
import CheckingAccountTab from '../../../views/companies/CheckingAccountTab';
import AgreementsTab from '../../../views/companies/AgreementsTab';
import PatientsTab from '../../../views/companies/PatientsTab';
import EmployeesTab from '../../../views/companies/EmployeesTab';
import SummaryTab from '../../../views/companies/SummaryTab';
import CustomChip from 'src/@core/components/mui/chip';
import { ThemeColor } from 'src/@core/layouts/types';
import CardHeader from '@mui/material/CardHeader';
import OptionsMenu from 'src/@core/components/option-menu';
import { Dialog, DialogActions, DialogContent } from '@mui/material';
import DialogAction from 'src/@core/components/custom-dialog-action';
import { maxHeight } from '@mui/system';
import { dynamicGet, dynamicUpdate } from 'src/services/entitiesDynamicServices';
import { DEFAULT_ORGANIZATION_ID } from 'src/configs/appConfig';
import {
  IApplicantQuotation,
  QuotationStatusTypes,
  ApplicantsStateTypes,
  IApplicant,
  ApplicantDispositives,
} from 'src/types/@autogenerated';
import DialogInformation from 'src/@core/components/custom-dialog-information';
import { UserDefinedRols } from 'src/types/userDefinedRols';
import { AppRols } from 'src/types/appRols';
import DynamicForm from 'src/views/components/dynamics/DynamicForm';
import RequiredServiceTab from 'src/views/applicants/RequiredServiceTab';

const SCHEMA_NAME = CMSCollections.COMPANIES;

const CompanyEdit = ({}: InferGetStaticPropsType<typeof getStaticProps>) => {
  // ** Hooks
  const router = useRouter();
  const dynamics = useDynamics();
  const currentUser = useCurrentUser();
  const { t } = useTranslation();

  const theme = useTheme();

  // ** Global vars
  const INITIAL_TAB = 'summary';
  const id = router.query.id as string | null;
  const tab = router.query['tab'] as string;

  // ** States
  const [entitySchema, setEntitySchema] = useState<IEntitySchema | null>(null);
  const [entitySchemaFields, setEntitySchemaFields] = useState<IEntitySchemaField[]>([]);
  const [loadingSchema, setLoadingSchema] = useState<boolean>(true);
  const [loadingData, setLoadingData] = useState<boolean>(false);
  const [entityData, setEntityData] = useState<ICompany | null>(null);
  const [toggleData, setToggleData] = useState<boolean>(false);
  // const [address, setAddress] = useState<string>('');
  const [activeTab, setActiveTab] = useState<string>(tab ? tab : INITIAL_TAB);
  const [editEntityForm, setEditEntityForm] = useState<IForm | null>(null);
  const [editEntityFormReject, setEditEntityFormReject] = useState<IForm | null>(null);
  const [editSidebarOpen, setEditSidebarOpen] = useState<boolean>(false);

  // ** dialogs
  const [approveDialogShow, setApproveDialogShow] = useState<boolean>(false);
  const [rejectDialogShow, setRejectDialogShow] = useState<boolean>(false);
  const [interviewScheduledDialogShow, setInterviewScheduledDialogShow] = useState<boolean>(false);
  const [pendingQuotationDialogShow, setPendingQuotationDialogShow] = useState<boolean>(false);
  const [successCreationPatientDialogShow, setSuccessCreationPatientDialogShow] = useState<boolean>(false);
  const [errorCreationPatientDialogShow, setErrorCreationPatientDialogShow] = useState<boolean>(false);

  const toggleEditDrawer = () => setEditSidebarOpen(!editSidebarOpen);
  const toggleRejectDialog = () => setRejectDialogShow(!rejectDialogShow);

  // ** Effects

  // fetch schema
  useEffect(() => {
    const doAsync = async () => {
      try {
        setLoadingSchema(true);

        if (!dynamics.entitySchemas || !dynamics.entitySchemasFields) return null;

        const schema = dynamics.entitySchemas.find((schema) => {
          return schema.name === SCHEMA_NAME;
        });
        if (!schema) throw new Error('Missing schemaName: ' + SCHEMA_NAME);
        const schemaFields = dynamics.entitySchemasFields.filter((field) => {
          return field.schemaId === schema.id;
        });

        // Fetch Schema
        //const entitySchemaResponse = (await getEntitySchemaByName(schemaName)) as IEntitySchemaWithFields;
        const entitySchemaResponse: IEntitySchemaWithFields = { ...schema, fields: schemaFields };

        setEntitySchema(entitySchemaResponse);

        // Fetch Fields
        // const entitySchemaFieldsResponse = await listEntitySchemaFields(entitySchemaResponse.id);

        setEntitySchemaFields(
          entitySchemaResponse.fields.sort((a, b) => {
            return a.order - b.order;
          })
        );

        setLoadingSchema(false);
      } catch (e: any) {
        handleError(e);
        setLoadingSchema(false);
      }
    };

    doAsync();
  }, [dynamics.entitySchemas, dynamics.entitySchemasFields]);

  // fetch entity data
  // ** DIRECCION
  useEffect(() => {
    if (!id) return;

    const doAsync = async () => {
      try {
        if (!entitySchema || currentUser.isLoading || loadingData) return;

        setLoadingData(true);

        if (!currentUser.currentUser) throw new Error('Missing currentUser.currentUser');

        const data: any = await getEntityDataBySchema(
          currentUser.currentUser,
          entitySchema,
          entitySchemaFields,
          id,
          null,
          null
        );

        setEntityData(data);

        // setAddress(data.applicantAddress['addressObject']['formatted_address']);
        setLoadingData(false);
      } catch (e: any) {
        handleError(e);
        setLoadingData(false);
      }
    };

    doAsync();
  }, [entitySchema, id, toggleData, currentUser.isLoading]);

  const handleTabChange = (event: SyntheticEvent, value: string) => {
    setLoadingSchema(true);
    setActiveTab(value);

    router
      .push({
        pathname: `/${SCHEMA_NAME}/${id}`,
        query: `tab=${value}`,
      })
      .then(() => setLoadingSchema(false));
  };

  useEffect(() => {
    if (tab && tab !== activeTab) {
      setActiveTab(tab);
    }
  }, [tab]);

  const handleOnEntityEdit = async () => {
    try {
      if (!entitySchema) throw new Error('missing entitySchema');

      const fieldsNames = ['name', 'contactName', 'contactEmail', 'contactPhone'];

      // No se que es
      // if (currentUser.currentUser?.appRols && hasRole(currentUser.currentUser?.appRols, AppRols.APP_ADMIN)) {
      //   fieldsNames.push(nameof<IApplicant>('applicantStateType'));
      // }

      const toShowFields = entitySchemaFields.filter((field) => {
        return fieldsNames.includes(field.name);
      });
      const theForm = schemaToForm(entitySchema, toShowFields, null, dynamics);

      setEditEntityForm(theForm);

      setEditSidebarOpen(true);
    } catch (e: any) {
      handleError(e);
    }
  };

  const handleOnEntityReject = async () => {
    try {
      if (!entitySchema) throw new Error('missing entitySchema');

      const fieldsNames = ['rejectionCause'];

      const toShowFields = entitySchemaFields.filter((field) => {
        return fieldsNames.includes(field.name);
      });
      const theForm = schemaToForm(entitySchema, toShowFields, null, dynamics);

      setEditEntityFormReject(theForm);

      setRejectDialogShow(true);
    } catch (e: any) {
      handleError(e);
    }
  };

  const handleOnEntityRestore = async () => {
    try {
      if (!id) return;

      setLoadingData(true);

      if (!entitySchema || !currentUser.currentUser) throw new Error('Missing entitySchema/currentUser.currentUser');

      await restoreEntityDataBySchema(
        currentUser.currentUser,
        entitySchema,
        entitySchemaFields,
        id,

        null,
        null
      );

      // refresco la info
      setToggleData(!toggleData);

      toast.success('successfull restored');

      // cierro sidebar
      setEditSidebarOpen(false);

      // apago loading
      setLoadingData(false);
    } catch (e) {
      setLoadingData(false);
      handleError(e);
    }
  };

  const handleOnEditSubmit = async (formData: any) => {
    try {
      if (!id) return;

      setLoadingData(true);

      if (!entitySchema || !currentUser.currentUser) throw new Error('Missing entitySchema/currentUser.currentUser');

      await updateEntityDataBySchema(
        currentUser.currentUser,
        entitySchema,
        entitySchemaFields,
        id,
        formData,
        null,
        null
      );

      // refresco la tabla
      setToggleData(!toggleData);

      // cierro sidebar
      setEditSidebarOpen(false);

      // apago loading
      setLoadingData(false);
    } catch (e) {
      setLoadingData(false);
      handleError(e);
    }
  };

  const handleOnEditRejectSubmit = async (formData: any) => {
    try {
      if (!id) return;

      setLoadingData(true);

      if (!entitySchema || !currentUser.currentUser) throw new Error('Missing entitySchema/currentUser.currentUser');

      const itemValues = { ...formData };

      itemValues.applicantStateType = ApplicantsStateTypes.REJECTED;

      await updateEntityDataBySchema(
        currentUser.currentUser,
        entitySchema,
        entitySchemaFields,
        id,
        itemValues,
        null,
        null
      );

      // refresco la tabla
      setToggleData(!toggleData);

      // cierro dialog
      setRejectDialogShow(false);

      // apago loading
      setLoadingData(false);
    } catch (e) {
      setLoadingData(false);
      handleError(e);
    }
  };

  const handleOnTabUpdateData = async () => {
    try {
      // refresco la tabla
      setToggleData(!toggleData);
    } catch (e) {
      handleError(e);
    }
  };

  const handleApproveDialogClose = () => {
    return setApproveDialogShow(false);
  };
  const handleRejectDialogClose = () => {
    return setRejectDialogShow(false);
  };
  const handleWaitingInterviewDialogClose = () => {
    return setInterviewScheduledDialogShow(false);
  };
  const handlePendingQuotationDialogClose = () => {
    return setPendingQuotationDialogShow(false);
  };

  const updateApplicant = async (formData: any) => {
    let response = null;

    response = await dynamicUpdate({
      params: `/cms/${SCHEMA_NAME}/` + id,
      data: formData,
    });
  };

  const closeAllDialogs = () => {
    setApproveDialogShow(false);
    setRejectDialogShow(false);
    setInterviewScheduledDialogShow(false);
    setPendingQuotationDialogShow(false);
  };
  const isPermittedByRol = () => {
    return (
      !currentUser.isLoading &&
      !!currentUser.currentUser &&
      (hasRole(currentUser.currentUser?.appRols, AppRols.APP_ADMIN) ||
        hasRole(currentUser.currentUser?.userDefinedRols, UserDefinedRols.UDR_STAFF_ADMISSION))
    );
  };

  const renderLeftPanel = () => {
    if (!entitySchema || !entityData) return;

    return (
      <Grid container spacing={6}>
        <DialogAction
          show={interviewScheduledDialogShow}
          title='interview-scheduled'
          text='applicant waiting interview confirm'
          textButtonSubmit='change'
          colorButtonSubmit='primary'
          // onClickSubmit={() => handleApplicantStateUpdate(ApplicantsStateTypes.INTERVIEW_SCHEDULED)}
          onClickClose={() => handleWaitingInterviewDialogClose()}
        />

        <DialogAction
          show={approveDialogShow}
          title='Aprobar'
          text='applicant approve confirm'
          textButtonSubmit='approve'
          // onClickSubmit={() => handleApplicantStateUpdate(ApplicantsStateTypes.CONVERTED)}
          onClickClose={() => handleApproveDialogClose()}
        />

        <DialogAction
          show={pendingQuotationDialogShow}
          title='interview completed'
          text='applicant pending quotation confirm'
          textButtonSubmit='change'
          colorButtonSubmit='info'
          // onClickSubmit={() => handleApplicantStateUpdate(ApplicantsStateTypes.PENDING_QUOTATION)}
          onClickClose={() => handlePendingQuotationDialogClose()}
        />

        <DialogAction
          show={rejectDialogShow}
          title='Rechazar'
          textButtonSubmit='reject'
          colorButtonSubmit='warning'
          onClickClose={() => handleRejectDialogClose()}
          showOnClickClose={false}
        >
          <DynamicForm
            initialValues={entityData}
            formId={'Edit_' + entitySchema?.name}
            preloadForm={editEntityFormReject}
            isCreating={false}
            onCancel={handleRejectDialogClose}
            onSubmit={handleOnEditRejectSubmit}
            onSubmitDone={() => {
              toggleRejectDialog();

              return Promise.resolve();
            }}
          />
        </DialogAction>

        <DialogInformation
          show={successCreationPatientDialogShow}
          title='Paciente creado con éxito'
          text='Su información ya esta disponible en la seccion de Paciente'
          color='success'
          onClickClose={() => {
            return setSuccessCreationPatientDialogShow(!successCreationPatientDialogShow);
          }}
        />

        <DialogInformation
          show={errorCreationPatientDialogShow}
          icon={'tabler:exclamation-circle'}
          title='Error'
          text='Solicitud no tiene presupuesto aprobado'
          color='warning'
          onClickClose={() => {
            return setErrorCreationPatientDialogShow(!errorCreationPatientDialogShow);
          }}
        />

        <Grid item xs={12}>
          <Card>
            {entityData.state !== 0 && (
              <CardHeader
                action={
                  isPermittedByRol() ? (
                    <OptionsMenu
                      options={[
                        {
                          text: capitalize(t('edit')),
                          menuItemProps: {
                            sx: { py: 2 },
                            onClick: () => {
                              handleOnEntityEdit();
                            },
                          },
                        },
                      ]}
                      iconButtonProps={{ size: 'small', sx: { color: 'text.disabled' } }}
                    />
                  ) : (
                    ''
                  )
                }
              />
            )}
            <CardContent sx={{ pt: 13.5, display: 'flex', alignItems: 'center', flexDirection: 'column' }}>
              <CustomAvatar
                skin='light'
                variant='rounded'
                color={'primary'}
                sx={{ width: 100, height: 100, mb: 4, fontSize: '3rem' }}
              >
                {getInitials(capitalize(entityData.name))}
              </CustomAvatar>

              <Typography variant='h4' sx={{ mb: 3, textTransform: 'capitalize' }}>
                {entityData.name}
              </Typography>
            </CardContent>

            <Divider sx={{ my: '0 !important', mx: 6 }} />

            <CardContent sx={{ pb: 2 }}>
              <Box sx={{ pt: 2 }}>
                <Box sx={{ display: 'flex', mb: 3, margin: 2 }}>
                  <Grid sx={{ ml: 2 }}>
                    <Icon fontSize='1.2rem' icon={'tabler:address-book'} />
                  </Grid>
                  <Grid sx={{ ml: 2 }}>
                    <Typography sx={{ color: 'text.secondary' }}>{capitalize(entityData.contactName)}</Typography>
                  </Grid>
                </Box>
                <Box sx={{ display: 'flex', mb: 3, margin: 2 }}>
                  <Grid sx={{ ml: 2 }}>
                    <Icon fontSize='1.2rem' icon={'tabler:mail'} />
                  </Grid>
                  <Grid sx={{ ml: 2 }}>
                    {entityData.contactEmail ?? (
                      <Typography sx={{ color: 'text.secondary' }}>{entityData.contactEmail}</Typography>
                    )}
                  </Grid>
                </Box>
                <Box sx={{ display: 'flex', mb: 3, margin: 2 }}>
                  <Grid sx={{ ml: 2 }}>
                    <Icon fontSize='1.2rem' icon={'tabler:phone'} />
                  </Grid>
                  <Grid sx={{ ml: 2 }}>
                    <Typography sx={{ color: 'text.secondary' }}>{entityData.contactPhone}</Typography>
                  </Grid>
                </Box>
                <Box sx={{ display: 'flex', mb: 3, margin: 2 }}>
                  <Grid sx={{ ml: 2, maxHeight: 20 }}>
                    <Icon fontSize='1.2rem' icon={'tabler:map-pin'}></Icon>
                  </Grid>
                  <Grid sx={{ ml: 2 }}>
                    <Typography sx={{ color: 'text.secondary' }}></Typography>
                  </Grid>
                </Box>
              </Box>
            </CardContent>
          </Card>
        </Grid>
      </Grid>
    );
  };

  const renderRightPanel = () => {
    // si el value de actuve Tab se imprime antes de los tabs estalla el comp
    if (!activeTab || !entitySchema || !id || !entityData) return null;

    console.log('ACTIVE TAB: ' + activeTab);

    return (
      <TabContext value={activeTab}>
        <TabList
          variant='scrollable'
          scrollButtons='auto'
          onChange={handleTabChange}
          aria-label='forced scroll tabs'
          sx={{ borderBottom: (theme) => `1px solid ${theme.palette.divider}` }}
        >
          <Tab value={INITIAL_TAB} label={t('summary')} sx={{ textTransform: 'capitalize' }} />
          <Tab value={'employees'} label={t('employees')} sx={{ textTransform: 'capitalize' }} />
          <Tab value={'patients'} label={t('patients')} sx={{ textTransform: 'capitalize' }} />
          <Tab value={'agreements'} label={t('agreements')} sx={{ textTransform: 'capitalize' }} />
          <Tab value={'checking-account'} label={t('checking account')} sx={{ textTransform: 'capitalize' }} />
        </TabList>

        <TabPanel sx={{ p: 0 }} value={INITIAL_TAB}>
          <SummaryTab
            docId={id}
            companySchemaArg={entitySchema}
            companySchemaFieldsArg={entitySchemaFields}
            companyDataArg={entityData}
            onUpdateCompany={handleOnTabUpdateData}
          />
        </TabPanel>
        <TabPanel sx={{ p: 0 }} value={'employees'}>
          <EmployeesTab docId={id} />
        </TabPanel>
        <TabPanel sx={{ p: 0 }} value={'patients'}>
          <PatientsTab docId={id} />
        </TabPanel>
        <TabPanel sx={{ p: 0 }} value={'agreements'}>
          <AgreementsTab docId={id} />
        </TabPanel>
        <TabPanel sx={{ p: 0 }} value={'checking-account'}>
          <CheckingAccountTab docId={id} />
        </TabPanel>
      </TabContext>
    );
  };

  if (router.isFallback) {
    return <h1>Loading...</h1>;
  }

  if (!id) {
    toast.error('Missing id');
    console.error('Missing args', router);
    // router.push('/500');

    return <h1>Loading...</h1>;
  }

  if (!dynamics.entitySchemas || !dynamics.entitySchemasFields) return <Loader />;

  if (loadingSchema || loadingData) return <Loader />;

  if (!entityData) return <>Error loading data</>;

  return (
    <Grid container spacing={6}>
      <Grid item xs={12} md={12} lg={12}>
        <Card>
          {/* <CardContent sx={{ pt: 0, display: 'flex', alignItems: 'left', flexDirection: 'column' }}>back</CardContent> */}
          <IconButton
            color='inherit'
            onClick={() => {
              // TODO Hacer HistoryContext
              const splittedUrl = router.asPath.split('/');

              const backRoute = splittedUrl.reduce((prev, curr, index) => {
                if (index === splittedUrl.length - 2) return prev;

                return prev + '/' + curr;
              });

              router.push(backRoute);
            }}
          >
            <Icon fontSize='1.625rem' icon='tabler:arrow-badge-left-filled' />
          </IconButton>
          {entityData.state === 0 && (
            <Alert
              severity='warning'
              action={
                <Button
                  color='inherit'
                  size='small'
                  onClick={() => {
                    handleOnEntityRestore();
                  }}
                >
                  Undo
                </Button>
              }
            >
              <AlertTitle>This entity is deleted!</AlertTitle>
            </Alert>
          )}
        </Card>
      </Grid>

      <Grid item xs={12} md={5} lg={4}>
        {renderLeftPanel()}
      </Grid>
      <Grid item xs={12} md={7} lg={8}>
        {renderRightPanel()}
      </Grid>

      {!!editSidebarOpen && (
        <DynamicFormSidebar
          isCreating={false}
          onSubmit={handleOnEditSubmit}
          title={'Edit ' + entitySchema?.name}
          formId={'Edit_' + entitySchema?.name}
          initialValues={entityData}
          preloadForm={editEntityForm}
          open={editSidebarOpen}
          toggle={toggleEditDrawer}
          onSubmitDone={() => {
            toggleEditDrawer();

            return Promise.resolve();
          }}
        />
      )}
    </Grid>
  );
};

export const getStaticPaths: GetStaticPaths = () => {
  return {
    paths: [],
    fallback: true,
  };
};

export const getStaticProps: GetStaticProps = async ({ params }: GetStaticPropsContext) => {
  return {
    props: {
      id: params?.id,
      // tab: params?.tab,
    },
  };
};

export default CompanyEdit;
